{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "기본 레이아웃 개선 및 라우팅 최적화",
        "description": "기존 프로젝트의 레이아웃(헤더, 푸터, 네비게이션)을 보완하고, 라우팅 시스템을 최적화합니다. PRD에 명시된 링크들을 확인하여 업데이트하고, 반응형 디자인을 강화하여 전반적인 UI/UX를 개선합니다.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "- 기존 헤더, 푸터, 네비게이션 컴포넌트 리팩토링 및 기능 보완\n- 라우팅 구조 최적화 (예: 코드 스플리팅, 레이지 로딩 적용)\n- PRD 기반 네비게이션 링크 최신화\n- 모바일 및 태블릿 환경 대응을 위한 반응형 디자인 강화",
        "testStrategy": "최적화된 라우팅 시스템이 정상적으로 동작하는지 확인합니다. 업데이트된 네비게이션 링크가 정확한 페이지로 연결되는지 검증하고, 다양한 디바이스 및 화면 크기에서 개선된 반응형 레이아웃이 깨짐 없이 표시되는지 테스트합니다.",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "환영 및 교회 소개 페이지 내용 추가 및 수정",
        "description": "기존 '환영 및 교회 소개' 페이지들(인사말, 교회 비전, 섬기는 사람들)에 PRD에 명시된 내용을 추가하고 수정합니다.",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "medium",
        "details": "- 인사말 페이지: 담임목사 사진(오른쪽)과 3문단 텍스트 배치\n- 교회 비전 페이지: 3가지 비전을 설명하는 콘텐츠 페이지 구현\n- 섬기는 사람들 페이지: 추후 조직도 이미지를 쉽게 추가할 수 있는 기본 틀 제공",
        "testStrategy": "각 페이지의 콘텐츠와 레이아웃이 PRD의 명세와 일치하는지 시각적으로 확인합니다.",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "교회 연혁 타임라인 UI 개발",
        "description": "기존 '교회 연혁' 페이지에 50주년 역사를 보여주는 타임라인 형태의 UI를 구현합니다.",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "medium",
        "details": "사용자가 스크롤하며 시간 순서에 따라 주요 연혁을 확인할 수 있는 인터랙티브 타임라인 컴포넌트를 개발합니다.",
        "testStrategy": "타임라인 UI가 디자인 시안에 맞게 구현되었는지 확인하고, 다양한 디바이스에서 반응형으로 동작하는지 테스트합니다.",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "교회학교 페이지 콘텐츠 추가",
        "description": "기존 '교회학교' 페이지들(유아부, 아동부, 중고등부, 청년부)에 각 부서별 간단한 소개와 소식을 담을 수 있는 정적 콘텐츠를 추가합니다.",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "low",
        "details": "유아부, 아동부, 중고등부, 청년부 각 페이지에 부서 소개와 소식을 담은 정적 콘텐츠를 추가합니다.",
        "testStrategy": "각 부서별 페이지에 추가된 콘텐츠가 올바르게 표시되는지 확인하고, 네비게이션을 통해 정상적으로 접근 가능한지 검증합니다.",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "YouTube API 연동 백엔드 서비스 구축",
        "description": "YouTube Data API v3를 사용하여 지정된 재생목록의 영상 정보를 주기적으로 가져오는 백엔드 서버 구축이 완료되었습니다. 현재 서버는 PM2를 통해 실행 중입니다.",
        "status": "done",
        "dependencies": [],
        "priority": "low",
        "details": "- API 키를 안전하게 관리\n- '주일 설교', '찬양대', '특별 찬양' 재생목록 ID를 기반으로 영상 목록(제목, 썸네일, 영상 ID)을 가져오는 로직 구현\n- 프론트엔드에 데이터를 제공할 API 엔드포인트 생성\n- 주기적인 데이터 동기화를 위한 스케줄러(예: cron job) 설정",
        "testStrategy": "백엔드 서버가 지정된 주기로 YouTube 재생목록을 성공적으로 동기화하는지 로그를 통해 확인하고, API 엔드포인트가 올바른 데이터를 반환하는지 테스트합니다.",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "주일 말씀 페이지 프론트엔드 개발",
        "description": "백엔드에서 제공하는 YouTube 영상 데이터를 받아 '주일 설교', '찬양대', '특별 찬양' 목록을 화면에 표시하는 UI를 개발하고, 백엔드 API와 통신하기 위한 프론트엔드 API 클라이언트 모듈을 구현합니다.",
        "status": "done",
        "dependencies": [
          1,
          5
        ],
        "priority": "low",
        "details": "사용자가 각 카테고리별 영상 목록을 보고, 썸네일을 클릭하여 영상을 시청할 수 있는 인터페이스를 구현합니다. 백엔드 API와 통신하기 위한 API 클라이언트 모듈(예: Axios, Fetch API 래퍼)을 구현하여 데이터 요청 및 상태 관리를 처리합니다. YouTube에 새 영상이 추가되면 웹사이트에 자동으로 반영되어야 합니다.",
        "testStrategy": "백엔드 API(Task 5)와 연동하여 영상 목록이 정상적으로 표시되는지 확인합니다. API 클라이언트 모듈이 백엔드 엔드포인트와 정상적으로 통신하고 응답 데이터를 올바르게 파싱하는지 검증합니다. YouTube 재생목록에 영상을 추가/삭제했을 때 웹사이트에 반영되는지 테스트합니다.",
        "subtasks": [
          {
            "id": 1,
            "title": "",
            "description": "백엔드 API 연동을 위한 클라이언트 모듈 구현",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "",
            "description": "영상 목록 UI 컴포넌트 개발 ('주일 설교', '찬양대', '특별 찬양')",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 7,
        "title": "교회 소식 UI 컴포넌트 개발 (갤러리 형태)",
        "description": "기존 '교회 소식' 페이지에 교회 행사 사진 등을 표시할 갤러리 형태의 게시판 UI 컴포넌트를 구현합니다. 추후 Headless WordPress REST API와 연동될 것을 대비한 UI 템플릿입니다.",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "medium",
        "details": "이미지 썸네일 그리드 레이아웃을 구현합니다. API 연동 자체는 현재 범위에 포함되지 않으며, 목업(mock) 데이터로 UI를 개발합니다.",
        "testStrategy": "정적(목업) 데이터를 사용하여 갤러리 레이아웃이 디자인 명세에 맞게 표시되는지 확인합니다.",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "주보 페이지 UI 컴포넌트 개발 (분할 화면)",
        "description": "기존 '주보' 페이지에 좌/우 분할 화면 레이아웃을 구현합니다. 오른쪽에는 역대 주보 제목 목록을, 왼쪽에는 선택된 주보 이미지를 표시합니다. Headless WordPress 연동을 위한 UI 템플릿입니다.",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "medium",
        "details": "목업 데이터로 UI를 개발합니다.",
        "testStrategy": "목업 데이터를 사용하여 목록에서 항목을 선택했을 때 왼쪽 화면의 이미지가 올바르게 변경되는지 테스트합니다. 레이아웃이 다양한 화면 크기에서 유지되는지 확인합니다.",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "자유 게시판 UI 컴포넌트 개발 (읽기 전용)",
        "description": "기존 '자유 게시판' 페이지에 읽기 전용 기능을 가진 기본 UI를 구현합니다. (현재는 읽기 전용 기능만 구현)",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "low",
        "details": "게시글 목록과 본문을 볼 수 있는 간단한 인터페이스를 제공합니다. 쓰기/수정/삭제 기능은 포함하지 않습니다.",
        "testStrategy": "목업 데이터를 사용하여 게시글 목록과 상세 내용이 정상적으로 표시되는지 확인합니다.",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "최종 통합 및 배포 준비",
        "description": "개발된 모든 기능들을 통합하고, 최종 테스트를 거쳐 프로덕션 환경에 배포할 준비를 합니다.",
        "details": "- 전체 기능에 대한 QA(품질 보증) 수행\n- 빌드 및 배포 스크립트 작성\n- 프로덕션 환경 변수 설정",
        "testStrategy": "스테이징 환경에서 모든 기능이 요구사항대로 동작하는지 최종 검증합니다. 실제 배포 절차를 시뮬레이션합니다.",
        "priority": "high",
        "dependencies": [
          2,
          3,
          4,
          6,
          9
        ],
        "status": "done",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-30T19:28:17.619Z",
      "updated": "2025-08-31T02:50:47.300Z",
      "description": "Tasks for master context"
    }
  },
  "phase-2": {
    "tasks": [
      {
        "id": 1,
        "title": "공용 '히어로 배너' 컴포넌트 개발 (Develop Reusable 'Hero Banner' Component)",
        "description": "각 서브 페이지 상단에 공통으로 사용될 '히어로 배너' UI 컴포넌트를 개발합니다. 이를 통해 페이지의 시각적 통일성과 정보 전달력을 높입니다.",
        "details": "배경 이미지 URL과 페이지 제목 텍스트를 props로 받아 동적으로 콘텐츠를 표시해야 합니다. 반응형 디자인을 적용하여 데스크톱과 모바일 환경 모두에서 최적화된 형태로 보여야 합니다.",
        "testStrategy": "Storybook과 같은 UI 개발 도구를 사용하여 다양한 이미지와 텍스트 길이에 대한 컴포넌트의 렌더링을 테스트합니다. 브라우저 개발자 도구의 기기 에뮬레이션 기능으로 반응형 동작을 검증합니다.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "컴포넌트 기본 구조 및 Props 정의 (Define Component's Basic Structure and Props)",
            "description": "'HeroBanner' 컴포넌트 파일을 생성하고, 배경 이미지 URL과 페이지 제목을 받을 수 있도록 props 인터페이스를 정의합니다. 기본적인 JSX/HTML 마크업 구조를 작성합니다.",
            "dependencies": [],
            "details": "React/Vue 컴포넌트 파일(.tsx, .vue 등)을 생성합니다. TypeScript를 사용하는 경우, `backgroundImageUrl: string`과 `pageTitle: string`을 포함하는 props 타입을 정의합니다. 시맨틱 마크업을 고려하여 외부 컨테이너와 내부 제목 요소(예: <h1>)로 구성된 기본 골격을 만듭니다.",
            "status": "done",
            "testStrategy": "컴포넌트가 에러 없이 렌더링되고, 하드코딩된 기본 props 값이 화면에 표시되는지 확인합니다."
          },
          {
            "id": 2,
            "title": "데스크톱 버전 기본 스타일링 적용 (Apply Basic Styling for Desktop Version)",
            "description": "CSS(또는 CSS-in-JS)를 사용하여 데스크톱 화면 크기를 기준으로 히어로 배너의 기본 스타일을 구현합니다. props로 받은 배경 이미지를 적용하고, 페이지 제목 텍스트의 스타일을 디자인 시안에 맞게 조정합니다.",
            "dependencies": [],
            "details": "배경 이미지가 배너 영역을 가득 채우도록 `background-size: cover`, `background-position: center` 등의 속성을 적용합니다. 제목 텍스트가 이미지 위에서 잘 보이도록 적절한 폰트 색상, 크기, 그림자 효과(text-shadow) 등을 추가하고 중앙에 배치합니다.\n<info added on 2025-08-31T05:38:42.823Z>\n'부드러운 느낌'을 주기 위해 `sans-serif` 계열 폰트를 사용하고, 제목과 부제목은 함께 중앙 정렬합니다. 텍스트 가독성을 높이기 위해 그림자 효과는 은은하게 적용합니다.\n</info added on 2025-08-31T05:38:42.823Z>",
            "status": "done",
            "testStrategy": "지정된 이미지 URL이 배경으로 올바르게 표시되는지, 텍스트 스타일이 디자인과 일치하는지 시각적으로 검토합니다."
          },
          {
            "id": 3,
            "title": "반응형 디자인 구현 (모바일 뷰 최적화) (Implement Responsive Design for Mobile Optimization)",
            "description": "미디어 쿼리를 사용하여 모바일 화면 크기에서 히어로 배너의 레이아웃과 스타일이 최적화되도록 조정합니다. 배너의 높이, 텍스트 크기, 여백 등을 모바일 환경에 맞게 수정합니다.",
            "dependencies": [],
            "details": "일반적인 모바일 브레이크포인트(예: 768px)를 기준으로 미디어 쿼리를 작성합니다. 작은 화면에서 배너의 높이를 줄이고, 제목 텍스트의 크기를 조정하여 가독성을 확보합니다.",
            "status": "done",
            "testStrategy": "브라우저 개발자 도구의 기기 에뮬레이션 기능을 사용하여 다양한 모바일 화면 크기에서 레이아웃이 깨지지 않고 콘텐츠가 명확하게 보이는지 확인합니다."
          },
          {
            "id": 4,
            "title": "Storybook 연동 및 다양한 Props 케이스 테스트 (Integrate with Storybook and Test Prop Variations)",
            "description": "Storybook에 'HeroBanner' 컴포넌트를 등록하고, 다양한 케이스를 테스트할 수 있는 스토리를 작성합니다. 짧은 제목, 매우 긴 제목, 여러 종류의 배경 이미지를 props로 전달하여 각 상황에서 컴포넌트가 의도대로 렌더링되는지 확인합니다.",
            "dependencies": [],
            "details": "컴포넌트에 대한 `.stories.tsx` 파일을 생성합니다. 기본 상태, 긴 텍스트 상태, 특정 이미지 비율 상태 등 최소 3개 이상의 스토리를 작성하여 엣지 케이스를 시각적으로 테스트하고 문서화합니다.",
            "status": "done",
            "testStrategy": "작성된 각 스토리가 Storybook UI에서 정상적으로 렌더링되는지 확인하고, 컨트롤(Controls) 애드온을 통해 실시간으로 props를 변경하며 UI 변화를 테스트합니다."
          },
          {
            "id": 5,
            "title": "코드 리뷰, 문서화 및 최종 검수 (Code Review, Documentation, and Final Verification)",
            "description": "작성된 컴포넌트 코드의 가독성과 재사용성을 검토하고, 다른 개발자가 쉽게 사용할 수 있도록 props 사용법에 대한 간단한 주석이나 문서를 추가합니다. 최종적으로 모든 요구사항이 충족되었는지 검수합니다.",
            "dependencies": [],
            "details": "컴포넌트 상단에 JSDoc 형식으로 컴포넌트의 역할과 각 prop에 대한 설명을 추가합니다. 불필요한 코드를 제거하고 변수명을 명확하게 수정합니다. PR(Pull Request)을 생성하여 동료의 코드 리뷰를 요청합니다.\n<info added on 2025-08-31T05:40:23.693Z>\n또한, `subtitle`이나 `CTA 버튼`과 같은 선택적(optional) props의 사용법을 다른 개발자가 쉽게 이해하고 활용할 수 있도록 사용 예시를 포함한 문서를 보강합니다. 최종적으로 상위 태스크의 모든 요구사항이 충족되었는지 검수합니다.\n</info added on 2025-08-31T05:40:23.693Z>",
            "status": "done",
            "testStrategy": "원래 태스크의 요구사항(props, 반응형)과 테스트 전략(Storybook, 브라우저 에뮬레이션)이 모두 충족되었는지 체크리스트를 통해 최종 확인합니다."
          }
        ]
      },
      {
        "id": 2,
        "title": "콘텐츠 페이드인 애니메이션 효과 구현 (Implement Content Fade-in Animation)",
        "description": "페이지 로드 및 스크롤 시 콘텐츠가 부드럽게 나타나는 '페이드인' 효과를 적용하여 세련된 사용자 경험을 제공합니다.",
        "details": "Intersection Observer API 또는 관련 라이브러리(예: framer-motion)를 사용하여, 뷰포트에 진입하는 콘텐츠 요소에 애니메이션 효과를 적용합니다. 재사용이 가능하도록 커스텀 훅(Hook) 또는 고차 컴포넌트(HOC) 형태로 구현합니다.",
        "testStrategy": "여러 페이지에 적용하여 스크롤 시 애니메이션이 부드럽고 자연스럽게 동작하는지 확인합니다. Lighthouse와 같은 성능 측정 도구를 사용하여 애니메이션으로 인한 성능 저하가 없는지 검증합니다.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "애니메이션 구현 기술 선정 및 설계",
            "description": "Intersection Observer API와 framer-motion 라이브러리의 장단점을 비교 분석하여 프로젝트에 가장 적합한 기술을 선정하고, 이를 기반으로 재사용 가능한 커스텀 훅의 인터페이스(입력 props, 반환 값)를 설계합니다.",
            "dependencies": [],
            "details": "주요 평가 기준은 성능, 번들 크기, 개발 편의성입니다. 최종적으로 선택된 기술과 설계된 훅의 API 명세를 간단히 문서화합니다.",
            "status": "done",
            "testStrategy": "각 기술의 기본 예제를 프로토타이핑하여 성능(CPU 사용량, 프레임 드랍)을 비교 측정합니다."
          },
          {
            "id": 2,
            "title": "가시성 감지 커스텀 훅(useVisibility) 구현",
            "description": "선정된 기술(예: Intersection Observer API)을 사용하여, 특정 DOM 요소가 뷰포트에 진입했는지 여부를 감지하는 핵심 로직을 커스텀 훅으로 구현합니다.",
            "dependencies": [
              "2.1"
            ],
            "details": "훅은 감시할 요소에 부착할 ref 객체와 요소의 현재 가시성 상태(boolean)를 반환해야 합니다. 한 번 화면에 나타난 요소는 더 이상 감시하지 않도록 최적화 옵션을 포함합니다.",
            "status": "done",
            "testStrategy": "Jest와 React Testing Library를 사용하여 훅이 요소의 가시성 상태 변화를 정확히 반환하는지 단위 테스트를 작성합니다."
          },
          {
            "id": 3,
            "title": "페이드인 효과를 위한 CSS 스타일 정의",
            "description": "애니메이션의 시작(보이지 않는 상태)과 끝(보이는 상태)을 정의하는 CSS 클래스 또는 스타일을 작성합니다. 부드러운 전환 효과를 위해 transition 속성을 설정합니다.",
            "dependencies": [],
            "details": "초기 상태는 `opacity: 0`, `transform: translateY(20px)` 등으로 설정하고, 최종 상태는 `opacity: 1`, `transform: translateY(0)`으로 설정합니다. CSS Modules 또는 Styled-components를 사용하여 스타일을 캡슐화합니다.",
            "status": "done",
            "testStrategy": "정적 HTML 페이지에서 정의된 CSS 클래스를 요소에 토글하며 전환 효과가 의도대로 작동하는지 시각적으로 확인합니다."
          },
          {
            "id": 4,
            "title": "재사용 가능한 애니메이션 래퍼 컴포넌트(FadeIn) 개발",
            "description": "구현된 `useVisibility` 훅과 CSS 스타일을 결합하여, 자식 컴포넌트(children)를 감싸기만 하면 페이드인 효과가 적용되는 `FadeIn` 래퍼 컴포넌트를 개발합니다.",
            "dependencies": [
              "2.2",
              "2.3"
            ],
            "details": "이 컴포넌트는 내부적으로 `useVisibility` 훅을 호출하고, 반환된 가시성 상태에 따라 자식 요소에 동적으로 CSS 클래스를 적용합니다. 애니메이션 지연(delay), 강도(intensity) 등을 props로 제어할 수 있도록 구현합니다.\n<info added on 2025-08-31T05:42:49.891Z>\n사용자가 스크롤하여 화면 밖으로 나갔다가 다시 들어올 때마다 애니메이션이 반복 실행되도록 로직을 구현합니다.\n</info added on 2025-08-31T05:42:49.891Z>",
            "status": "done",
            "testStrategy": "Storybook을 사용하여 `FadeIn` 컴포넌트의 다양한 props(delay, direction 등)가 올바르게 동작하는지 시각적으로 테스트하고 문서화합니다."
          },
          {
            "id": 5,
            "title": "샘플 페이지 적용 및 애니메이션 미세 조정",
            "description": "임시 테스트 페이지를 만들어 다양한 종류의 콘텐츠(텍스트 블록, 이미지, 카드 리스트)에 `FadeIn` 컴포넌트를 적용하고, 실제 사용 환경에서 어떻게 보이는지 검증합니다.",
            "dependencies": [
              "2.4"
            ],
            "details": "스크롤 시 애니메이션의 시작 타이밍, 지속 시간, 이징(easing) 함수 등을 조정하여 가장 자연스럽고 세련된 사용자 경험을 제공하도록 값을 미세 조정합니다.\n<info added on 2025-08-31T05:43:37.280Z>\n애니메이션의 `transition-duration` 값을 조정하여, 사용자가 가장 편안하고 자연스럽게 느낄 수 있는 최적의 속도를 찾습니다.\n</info added on 2025-08-31T05:43:37.280Z>",
            "status": "done",
            "testStrategy": "여러 브라우저(Chrome, Firefox, Safari)와 디바이스(데스크톱, 모바일)에서 스크롤하며 애니메이션이 끊김 없이 부드럽게 동작하는지 교차 검증합니다."
          }
        ]
      },
      {
        "id": 3,
        "title": "10개 주요 페이지에 공통 디자인(배너, 애니메이션) 적용 (Apply Common Design to 10 Pages)",
        "description": "개발된 배너 컴포넌트와 페이드인 애니메이션을 PRD에 명시된 10개의 페이지에 통합 적용합니다.",
        "details": "적용 대상 페이지: 환영합니다(4), 교회소개(2), 교회학교(4). 각 페이지의 주제에 맞는 배너 이미지와 제목을 설정하고, 주요 콘텐츠 블록에 스크롤 애니메이션 효과를 적용합니다.",
        "testStrategy": "지정된 10개 페이지를 모두 방문하여 배너가 올바르게 표시되는지, 스크롤 애니메이션이 정상적으로 작동하는지 시각적으로 검수합니다. 페이지 간 이동 시에도 일관된 경험을 제공하는지 확인합니다.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "10개 페이지 배너 콘텐츠(이미지, 제목) 수집 및 정리",
            "description": "적용 대상인 10개 페이지(환영합니다 4, 교회소개 2, 교회학교 4) 각각의 주제에 맞는 배너 이미지와 제목 텍스트를 PRD를 기반으로 확정하고, 필요한 에셋을 준비합니다.",
            "dependencies": [],
            "details": "각 페이지의 정체성을 나타낼 수 있는 고품질 이미지를 선정하고, 제목 텍스트를 최종 결정합니다. 이미지 파일은 웹에 최적화된 포맷과 크기로 준비해야 합니다.\n<info added on 2025-08-31T05:44:44.389Z>\n실제 콘텐츠가 준비되기 전까지 개발을 진행할 수 있도록, 각 페이지의 주제에 맞는 고품질 임시 스톡 이미지와 제목/부제목 문구를 우선 적용하여 전체적인 UI 구조를 완성합니다.\n</info added on 2025-08-31T05:44:44.389Z>",
            "status": "done",
            "testStrategy": "준비된 이미지와 텍스트 목록이 PRD의 요구사항 및 각 페이지의 콘텐츠와 일치하는지 검토합니다."
          },
          {
            "id": 2,
            "title": "'환영합니다' 카테고리 4개 페이지에 디자인 적용",
            "description": "'환영합니다' 카테고리에 속한 4개의 페이지에 개발된 '히어로 배너' 컴포넌트와 페이드인 애니메이션을 통합 적용합니다.",
            "dependencies": [
              "3.1"
            ],
            "details": "각 페이지의 최상단에 배너 컴포넌트를 추가하고, 1번 서브태스크에서 준비한 이미지와 제목을 props로 전달합니다. 페이지의 주요 콘텐츠 블록에 스크롤 기반 페이드인 애니메이션을 적용합니다.",
            "status": "done",
            "testStrategy": "해당 4개 페이지를 브라우저에서 직접 확인하여 배너가 올바른 콘텐츠로 표시되는지, 스크롤 시 애니메이션이 정상 작동하는지 시각적으로 검수합니다."
          },
          {
            "id": 3,
            "title": "'교회소개' 카테고리 2개 페이지에 디자인 적용",
            "description": "'교회소개' 카테고리에 속한 2개의 페이지에 개발된 '히어로 배너' 컴포넌트와 페이드인 애니메이션을 통합 적용합니다.",
            "dependencies": [
              "3.1"
            ],
            "details": "각 페이지의 최상단에 배너 컴포넌트를 추가하고, 1번 서브태스크에서 준비한 이미지와 제목을 props로 전달합니다. 페이지의 주요 콘텐츠 블록에 스크롤 기반 페이드인 애니메이션을 적용합니다.",
            "status": "done",
            "testStrategy": "해당 2개 페이지를 브라우저에서 직접 확인하여 배너가 올바른 콘텐츠로 표시되는지, 스크롤 시 애니메이션이 정상 작동하는지 시각적으로 검수합니다."
          },
          {
            "id": 4,
            "title": "'교회학교' 카테고리 4개 페이지에 디자인 적용",
            "description": "'교회학교' 카테고리에 속한 4개의 페이지에 개발된 '히어로 배너' 컴포넌트와 페이드인 애니메이션을 통합 적용합니다.",
            "dependencies": [
              "3.1"
            ],
            "details": "각 페이지의 최상단에 배너 컴포넌트를 추가하고, 1번 서브태스크에서 준비한 이미지와 제목을 props로 전달합니다. 페이지의 주요 콘텐츠 블록에 스크롤 기반 페이드인 애니메이션을 적용합니다.",
            "status": "done",
            "testStrategy": "해당 4개 페이지를 브라우저에서 직접 확인하여 배너가 올바른 콘텐츠로 표시되는지, 스크롤 시 애니메이션이 정상 작동하는지 시각적으로 검수합니다."
          },
          {
            "id": 5,
            "title": "10개 페이지 전체 통합 검수 및 반응형 테스트",
            "description": "디자인이 적용된 10개 페이지 전체를 대상으로 배너와 애니메이션의 동작, 시각적 일관성을 최종 검수하고 다양한 화면 크기에서의 레이아웃을 확인합니다.",
            "dependencies": [
              "3.2",
              "3.3",
              "3.4"
            ],
            "details": "페이지 간 이동 시에도 디자인이 일관되게 유지되는지 확인합니다. 브라우저 개발자 도구를 사용하여 데스크톱과 모바일 뷰포트에서 배너와 콘텐츠 레이아웃이 깨지지 않는지 점검하고 미세 조정을 진행합니다.",
            "status": "done",
            "testStrategy": "Task 3의 전체 테스트 전략에 따라 10개 페이지를 모두 방문하며 시각적 검수를 수행하고, 발견된 문제를 수정하여 최종 완료 처리합니다."
          }
        ]
      },
      {
        "id": 4,
        "title": "Headless WordPress API 연동 설정 (Configure Headless WordPress API Integration)",
        "description": "웹사이트에서 Headless WordPress의 데이터를 가져오기 위한 기본 연동 설정을 구축합니다.",
        "details": "WordPress GraphQL 또는 REST API 엔드포인트 연결을 설정하고, 환경 변수를 사용하여 API URL을 안전하게 관리합니다. 지정된 카테고리별로 게시물 목록을 조회하는 기본 데이터 fetching 함수를 구현합니다.",
        "testStrategy": "API 클라이언트(예: Postman)나 테스트 스크립트를 사용하여 특정 카테고리 ID로 게시물 데이터를 성공적으로 가져오는지 확인하고, 반환되는 데이터의 구조를 검증합니다.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "API 방식 결정 및 WordPress 플러그인 설치 (Decide on API method and install WordPress plugins)",
            "description": "프로젝트 요구사항에 맞춰 REST API와 GraphQL 중 사용할 API 방식을 결정합니다. GraphQL을 사용하기로 결정한 경우, WordPress에 WPGraphQL 플러그인을 설치하고 활성화합니다.",
            "dependencies": [],
            "details": "REST API는 WordPress에 기본 내장되어 있으며, GraphQL은 추가 플러그인 설치가 필요합니다. 데이터 요청의 유연성과 성능을 고려하여 적합한 방식을 선택합니다.\n<info added on 2025-09-02T11:12:45.545Z>\n\n\n결정 사항: WordPress에 기본 내장된 REST API를 사용합니다. 별도의 GraphQL 플러그인 설치는 필요하지 않습니다.\n</info added on 2025-09-02T11:12:45.545Z>",
            "status": "done",
            "testStrategy": "WordPress 관리자 페이지에서 플러그인이 성공적으로 활성화되었는지 확인합니다. GraphQL의 경우 GraphiQL IDE, REST의 경우 브라우저에서 기본 엔드포인트(/wp-json/)에 접근하여 기본 응답이 오는지 확인합니다."
          },
          {
            "id": 2,
            "title": "API 엔드포인트 환경 변수 설정 (Configure API endpoint environment variables)",
            "description": "프론트엔드 프로젝트의 .env 파일에 WordPress API URL을 환경 변수로 추가하여 관리합니다. 이를 통해 소스 코드에서 URL을 분리하여 보안과 관리 용이성을 높입니다.",
            "dependencies": [
              "4.1"
            ],
            "details": "NEXT_PUBLIC_WORDPRESS_API_URL과 같은 명확한 변수명을 사용합니다. 개발, 스테이징, 프로덕션 환경별로 다른 엔드포인트를 설정할 수 있도록 .env.local, .env.development 등의 파일을 활용합니다.\n<info added on 2025-08-31T05:55:10.982Z>\nVite 프로젝트(`seongrim`)의 루트에 `.env.local` 파일을 생성하고, 다음과 같이 환경 변수를 설정합니다. Vite의 규칙에 따라 클라이언트 사이드에서 변수에 접근할 수 있도록 `VITE_` 접두사를 사용합니다.\n```\nVITE_API_URL=https://api.seongrim.o-r.kr/wp-json\n```\n",
            "status": "done",
            "testStrategy": "프로젝트를 실행한 후, 코드 내에서 process.env.NEXT_PUBLIC_WORDPRESS_API_URL 값을 콘솔에 출력하여 올바른 URL이 로드되는지 확인합니다."
          },
          {
            "id": 3,
            "title": "프론트엔드 API 클라이언트 모듈 생성 (Create a frontend API client module)",
            "description": "API 요청을 중앙에서 처리하기 위한 재사용 가능한 API 클라이언트 모듈을 생성합니다. 이 모듈은 환경 변수에서 API URL을 읽어와 요청의 기본 설정을 담당합니다.",
            "dependencies": [
              "4.2"
            ],
            "details": "axios 또는 fetch API를 사용하여 클라이언트를 구현합니다. GraphQL의 경우, Apollo Client나 graphql-request와 같은 라이브러리를 설정하여 쿼리를 쉽게 보낼 수 있도록 구성합니다.\n<info added on 2025-09-02T11:13:12.985Z>\n프로젝트에 이미 `axios`가 의존성으로 설정되어 있으므로, `axios`를 사용하여 구현합니다.\n</info added on 2025-09-02T11:13:12.985Z>",
            "status": "done",
            "testStrategy": "생성된 클라이언트 모듈을 사용하여 WordPress의 기본 정보(예: 사이트 제목)를 가져오는 간단한 테스트 함수를 실행하고, 200 OK 응답을 받는지 확인합니다."
          },
          {
            "id": 4,
            "title": "카테고리별 게시물 조회 데이터 fetching 함수 구현 (Implement data fetching function for posts by category)",
            "description": "특정 카테고리 ID를 인자로 받아, 해당 카테고리에 속한 게시물 목록을 조회하는 비동기 함수(예: getPostsByCategory)를 API 클라이언트 모듈을 사용하여 구현합니다.",
            "dependencies": [
              "4.3"
            ],
            "details": "REST API의 경우 `/wp/v2/posts?categories=<id>` 엔드포인트를, GraphQL의 경우 `posts(where: { categoryId: <id> })`와 같은 쿼리를 사용합니다. 함수는 후속 작업(Task 5)에 필요한 필드(제목, 날짜, 요약 등)를 포함하여 반환해야 합니다.\n<info added on 2025-09-02T11:13:39.550Z>\n초기 구현 시, 함수는 각 게시물에 대해 다음 필드를 우선적으로 가져와야 합니다: `id`, `title`, `content`, `excerpt`, `date`, `author`, `featured_media`. 또한, 향후 다른 필드가 필요할 경우 쉽게 추가할 수 있도록 확장성을 고려하여 설계해야 합니다.\n</info added on 2025-09-02T11:13:39.550Z>",
            "status": "done",
            "testStrategy": "단위 테스트를 작성하여 특정 카테고리 ID를 함수에 전달했을 때, 예상되는 구조의 게시물 데이터 배열이 반환되는지 검증합니다. 존재하지 않는 카테고리 ID에 대한 예외 처리도 확인합니다."
          },
          {
            "id": 5,
            "title": "API 응답 데이터 타입 정의 및 최종 연동 테스트 (Define API response types and conduct final integration test)",
            "description": "API로부터 반환되는 게시물 데이터의 구조에 맞춰 TypeScript 인터페이스 또는 JSDoc 타입을 정의하여 코드의 안정성을 확보합니다. 구현된 fetching 함수를 실제로 호출하여 전체 연동 과정을 테스트합니다.",
            "dependencies": [
              "4.4"
            ],
            "details": "Postman과 같은 도구로 실제 API 응답을 확인하고, 이를 기반으로 'Post' 타입을 정의합니다. 이 타입은 getPostsByCategory 함수의 반환 타입으로 명시하여 타입 안정성을 높입니다.\n<info added on 2025-09-02T11:14:25.045Z>\n프로젝트가 JavaScript로 진행되므로, TypeScript 인터페이스 대신 JSDoc 주석을 활용하여 API 응답 데이터 타입을 정의합니다. 이를 통해 코드 안정성과 개발자 경험을 향상시킵니다.\n</info added on 2025-09-02T11:14:25.045Z>",
            "status": "done",
            "testStrategy": "테스트용 페이지 컴포넌트에서 getPostsByCategory 함수를 호출하고, 반환된 데이터가 정의된 타입과 일치하는지, 그리고 화면에 정상적으로 렌더링되는지 확인합니다. 데이터가 없을 경우 빈 배열이 올바르게 처리되는지도 테스트합니다."
          }
        ]
      },
      {
        "id": 5,
        "title": "공용 BoardPage 컴포넌트 개발 및 게시판 페이지 구현",
        "description": "초기 계획을 수정하여, 재사용 가능한 BoardPage 공용 컴포넌트를 먼저 개발하고, 이를 활용해 '주보'와 '교회 소식' 페이지를 효율적으로 구현한다. API 응답 헤더(X-WP-TotalPages)를 이용한 페이지네이션과 URL 쿼리 스트링(?page=...)을 통한 페이지 상태 관리를 포함한다.",
        "details": "",
        "testStrategy": "",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "페이지네이션을 지원하는 데이터 Fetching 함수 개선",
            "description": "4번 태스크에서 만든 axios 클라이언트를 개선하여, API 요청 시 응답 본문(게시물 목록)과 함께 응답 헤더의 X-WP-TotalPages 값('전체 페이지 수')을 함께 반환하도록 수정한다. 페이지 번호를 인자로 받아 해당 페이지의 데이터를 요청하는 기능을 포함한다.",
            "dependencies": [],
            "details": "",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "공용 게시물 UI 컴포넌트 개발 (PostList, Pagination)",
            "description": "데이터를 받아 화면에 표시하는 역할만 담당하는 순수 UI 컴포넌트를 개발한다. 1) 게시물 목록과 아이템을 위한 PostList/PostListItem, 2) 페이지 번호를 표시하고 이동 이벤트를 처리할 Pagination 컴포넌트를 포함한다.",
            "dependencies": [],
            "details": "",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "핵심 로직을 담은 'BoardPage' 공용 컴포넌트 개발",
            "description": "categoryId와 title을 props로 받는 재사용 가능한 BoardPage 컴포넌트를 개발한다. 이 컴포넌트는 다음 핵심 로직을 모두 담당한다: 1) URL 쿼리 스트링에서 page 값을 읽어 API 호출, 2) use-effect와 use-state를 사용한 데이터 상태 관리(게시물, 전체 페이지 수, 로딩, 에러), 3) 로딩/에러 상태에 따른 UI 분기 처리, 4) 데이터와 이벤트 핸들러를 UI 컴포넌트(PostList, Pagination)에 전달.",
            "dependencies": [
              "5.1",
              "5.2"
            ],
            "details": "",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "'주보' 및 '교회 소식' 페이지 최종 조립",
            "description": "react-router-dom을 이용해 /bulletin과 /church-news 경로에 페이지를 생성한다. 각 페이지에서는 BoardPage 공용 컴포넌트를 가져와, 각각에 맞는 categoryId와 title props를 전달하여 최종 페이지를 완성한다. (예: <BoardPage categoryId={1} title=\"주보\" />)",
            "dependencies": [
              "5.3"
            ],
            "details": "",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "반응형 디자인 적용 및 최종 테스트",
            "description": "개발된 모든 공용 컴포넌트(PostList, Pagination 등)에 반응형 스타일을 적용한다. 최종 조립된 '주보'와 '교회 소식' 두 페이지가 데스크톱, 태블릿, 모바일 등 다양한 화면 크기에서 정상적으로 표시되는지 확인하고 테스트한다.",
            "dependencies": [
              "5.4"
            ],
            "details": "",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "'앨범' 페이지 갤러리 레이아웃 구현 (Implement 'Album' Page with Gallery Layout)",
        "description": "WordPress '앨범' 게시물의 본문에 포함된 모든 이미지를 가져와, 사진 중심의 갤러리 페이지를 개발한다. 메이슨리(Masonry) 레이아웃, 무한 스크롤, 스켈레톤 로더, 라이트박스 기능을 포함하여 사용자 경험을 극대화한다.",
        "details": "",
        "testStrategy": "",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "'앨범' 게시물 이미지 파싱 및 API 함수 고도화",
            "description": "'앨범' 카테고리 게시물을 페이지별로 요청하고, 각 게시물 본문(HTML)에서 모든 이미지(`<img>`) 태그를 추출하는 데이터 페칭(fetching) 함수를 구현한다. 무한 스크롤을 위해 페이지 번호를 인자로 받고, 전체 페이지 수를 반환하는 기능을 포함한다.",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "스켈레톤 UI 및 갤러리 아이템 컴포넌트 개발",
            "description": "데이터 로딩 상태를 표시할 메이슨리 레이아웃 형태의 스켈레톤 UI를 개발한다. 또한, 개별 이미지를 화면에 표시할 `GalleryItem` 컴포넌트를 만든다.",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "메이슨리 레이아웃 및 무한 스크롤 기능 구현",
            "description": "`react-masonry-css`를 사용하여 갤러리 레이아웃을 구성한다. 사용자가 페이지 하단에 도달하면 다음 페이지의 이미지를 자동으로 불러와 기존 목록에 추가하는 무한 스크롤 기능을 구현한다.",
            "status": "done",
            "dependencies": [
              "6.1",
              "6.2"
            ],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "라이트박스 기능 연동",
            "description": "`yet-another-react-lightbox` 라이브러리를 `GalleryItem`과 연동한다. 이미지 클릭 시, 현재까지 로드된 모든 이미지를 탐색할 수 있는 라이트박스가 열리도록 구현한다.",
            "status": "done",
            "dependencies": [
              "6.3"
            ],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "반응형 디자인 최종 적용 및 통합 테스트",
            "description": "메이슨리 레이아웃, 무한 스크롤, 라이트박스 등 구현된 모든 기능이 데스크톱, 태블릿, 모바일 환경에서 올바르게 동작하는지 최종 테스트하고 디자인을 미세 조정한다.",
            "status": "done",
            "dependencies": [
              "6.4"
            ],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 9,
        "title": "YouTube 연동 페이지 프론트엔드 UI/UX 구현 (Implement YouTube Integration Frontend UI)",
        "description": "주일 설교, 찬양대, 특별 찬양 페이지에서 자체 백엔드 API를 통해 영상 목록을 받아와 카드 형태로 표시합니다.",
        "details": "3개의 각 페이지는 자체 백엔드 API 엔드포인트(Task 8)를 호출하여 영상 데이터를 가져옵니다. 썸네일, 제목, 재생 시간 등의 정보를 포함하는 카드 UI 컴포넌트를 개발하고, 이를 사용하여 비디오 목록을 렌더링합니다.",
        "testStrategy": "각 페이지가 올바른 재생목록 데이터를 표시하는지 확인합니다. 카드 UI가 디자인 시안과 일치하는지, 반응형 디자인이 잘 적용되었는지 다양한 디바이스에서 검수합니다. 데이터 로딩 중/에러 발생 시의 UI 상태도 확인합니다.",
        "priority": "high",
        "dependencies": [
          "12"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "재사용 가능한 '영상 카드' UI 컴포넌트 개발",
            "description": "YouTube 영상의 썸네일, 제목, 재생 시간 등 주요 정보를 표시하는 재사용 가능한 카드 형태의 UI 컴포넌트를 개발합니다. 이 컴포넌트는 모든 영상 목록 페이지에서 공통으로 사용됩니다.",
            "dependencies": [],
            "details": "props를 통해 영상 데이터(thumbnailUrl, title, duration)를 받아 동적으로 렌더링하도록 구현합니다. 디자인 시안에 맞춰 HTML 구조와 CSS 스타일링을 적용하고, 클릭 시 YouTube 영상 페이지로 이동하는 링크를 포함합니다.",
            "status": "done",
            "testStrategy": "Storybook과 같은 UI 개발 도구를 사용하여 다양한 제목 길이와 썸네일 이미지에 대해 컴포넌트가 깨짐 없이 렌더링되는지 확인합니다."
          },
          {
            "id": 2,
            "title": "백엔드 API 연동을 위한 데이터 페칭 로직 구현",
            "description": "Task 8에서 개발된 백엔드 API 엔드포인트를 호출하여 특정 재생목록의 영상 데이터를 가져오는 로직을 구현합니다. 데이터 로딩, 성공, 실패 상태를 관리하는 기능을 포함합니다.",
            "dependencies": [],
            "details": "재사용성을 높이기 위해 React Query나 SWR과 같은 데이터 페칭 라이브러리를 사용하거나, `useFetchVideos`와 같은 커스텀 훅(Hook) 형태로 구현합니다. 이 훅은 playlistId를 인자로 받아 { data, isLoading, error } 상태 객체를 반환해야 합니다.",
            "status": "done",
            "testStrategy": "모의 API 서버(Mock Service Worker 등)를 사용하여 성공, 로딩 중, 에러 발생 시나리오별로 훅이 올바른 상태를 반환하는지 단위 테스트를 진행합니다."
          },
          {
            "id": 3,
            "title": "'주일 설교' 페이지 구현 및 영상 목록 렌더링",
            "description": "'주일 설교' 페이지의 전체 레이아웃을 구성하고, 개발된 데이터 페칭 로직과 영상 카드 컴포넌트를 조합하여 실제 영상 목록을 화면에 렌더링합니다.",
            "dependencies": [
              "9.1",
              "9.2"
            ],
            "details": "데이터 페칭 로직을 호출하여 '주일 설교' 재생목록 데이터를 가져옵니다. 로딩 중일 때는 스켈레톤 UI를, 에러 발생 시에는 사용자에게 안내 메시지를 표시합니다. 데이터 로딩이 완료되면 영상 카드 컴포넌트를 그리드 형태로 나열하여 목록을 표시합니다.",
            "status": "done",
            "testStrategy": "브라우저에서 페이지를 직접 확인하여 영상 목록이 올바르게 표시되는지, 로딩 및 에러 상태 UI가 정상적으로 작동하는지 검증합니다."
          },
          {
            "id": 4,
            "title": "'찬양대' 및 '특별 찬양' 페이지 구현",
            "description": "'주일 설교' 페이지와 동일한 구조를 재사용하여 '찬양대'와 '특별 찬양' 페이지를 구현합니다. 각 페이지에 맞는 재생목록 데이터를 API로부터 가져와 표시합니다.",
            "dependencies": [
              "9.3"
            ],
            "details": "기존에 구현된 페이지 구조와 컴포넌트를 재활용하되, 각 페이지에 해당하는 고유한 playlistId를 데이터 페칭 로직에 전달하여 올바른 영상 목록을 불러오도록 설정합니다.",
            "status": "done",
            "testStrategy": "각 페이지를 방문하여 해당 재생목록(찬양대, 특별 찬양)의 영상들이 정확하게 렌더링되는지 확인합니다."
          },
          {
            "id": 5,
            "title": "반응형 디자인 적용 및 최종 UI 검수",
            "description": "구현된 3개의 영상 목록 페이지 전체에 반응형 디자인을 적용하여 데스크톱, 태블릿, 모바일 등 다양한 디바이스에서 최적화된 UI/UX를 제공하도록 합니다.",
            "dependencies": [
              "9.4"
            ],
            "details": "미디어 쿼리를 사용하여 화면 너비에 따라 영상 카드 그리드의 컬럼 수를 동적으로 변경합니다. (예: 데스크톱 4열, 태블릿 2열, 모바일 1열) 폰트 크기, 여백 등을 조절하여 가독성을 확보합니다.",
            "status": "done",
            "testStrategy": "브라우저 개발자 도구의 디바이스 에뮬레이션 기능을 사용하여 주요 해상도별로 레이아웃이 깨지지 않는지 확인하고, 실제 모바일 기기에서도 테스트를 진행합니다."
          },
          {
            "id": 6,
            "title": "YouTubeVideoList 컴포넌트 개발",
            "description": "src/components/YouTubeVideoList.jsx 컴포넌트를 생성하여 YouTube 영상 목록을 표시하도록 구현합니다. playlistId를 prop으로 받아 백엔드 API를 호출하고, position 순서대로 영상을 정렬하여 썸네일, 제목, 게시일 등을 표시합니다.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 9
          },
          {
            "id": 7,
            "title": "VideoModal 컴포넌트 개발 및 스타일링",
            "description": "src/components/VideoModal.jsx 컴포넌트와 src/components/VideoModal.css 파일을 생성하여 영상 클릭 시 모달 창에서 YouTube 영상을 재생하는 기능을 구현합니다.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 9
          },
          {
            "id": 8,
            "title": "주일설교, 찬양대, 특별찬양 페이지에 컴포넌트 통합",
            "description": "SundaySermonPage.jsx, ChoirPage.jsx, SpecialPraisePage.jsx 세 페이지를 수정하여 기존의 가상 데이터를 제거하고, YouTubeVideoList와 VideoModal 컴포넌트를 통합합니다. 각 페이지에는 해당 플레이리스트 ID를 설정할 수 있는 플레이스홀더를 추가합니다.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 9
          }
        ]
      },
      {
        "id": 10,
        "title": "최종 통합 테스트 및 배포 준비 (Final Integration Testing & Deployment Prep)",
        "description": "구현된 모든 기능(디자인 개선, WordPress 연동, YouTube 연동)이 서로 문제없이 동작하는지 전체적으로 테스트하고 배포를 준비합니다.",
        "status": "in-progress",
        "dependencies": [
          3,
          5,
          6,
          9
        ],
        "priority": "medium",
        "details": "스테이징(Staging) 환경에서 모든 페이지와 기능을 점검합니다. 특히 페이지 간 이동, 데이터 로딩 속도, 애니메이션 효과 등 실제 사용자 시나리오를 기반으로 테스트를 진행하고 발견된 버그를 수정합니다.",
        "testStrategy": "QA 체크리스트를 작성하여 PRD의 모든 요구사항이 충족되었는지 확인합니다. 여러 브라우저(Chrome, Safari, Firefox)와 디바이스(데스크톱, 모바일)에서 크로스 브라우징 및 반응형 테스트를 수행합니다.",
        "subtasks": [
          {
            "id": 1,
            "title": "기능 및 UI/UX 수동 테스트 수행",
            "description": "구현된 모든 기능(디자인 개선, WordPress 연동, YouTube 연동)이 정상적으로 작동하는지, 그리고 UI/UX가 의도대로 표시되는지 수동으로 확인합니다.",
            "status": "done",
            "dependencies": [],
            "details": "WordPress 연동 기능(주보, 소식, 앨범)과 YouTube 연동 기능(설교, 찬양)을 중심으로 테스트합니다. `src/pages/bulletin`, `src/pages/news`, `src/pages/album` 등의 페이지와 `src/components/SermonList` 컴포넌트의 동작을 확인합니다.",
            "testStrategy": "실제 사용자와 동일한 환경에서 웹사이트를 직접 사용하며 기능적 오류나 UI 깨짐 현상을 확인합니다."
          },
          {
            "id": 2,
            "title": "발견된 문제점 확인 및 보고",
            "description": "테스트 중 발견된 문제점이나 개선이 필요한 부분을 정리하고 보고합니다.",
            "status": "done",
            "dependencies": [],
            "details": "발견된 버그는 재현 경로, 기대 결과, 실제 결과, 스크린샷을 포함하여 이슈 트래킹 시스템에 상세히 기록합니다. 특히, `framer-motion`으로 구현된 애니메이션의 부자연스러움이나 앨범 페이지의 레이아웃 문제를 중점적으로 확인합니다.",
            "testStrategy": "보고된 이슈는 심각도(Critical, Major, Minor)에 따라 우선순위를 지정하여 개발팀에 전달합니다."
          },
          {
            "id": 3,
            "title": "최종 확인 및 배포 준비",
            "description": "모든 기능이 대략적으로 확인되었음을 최종적으로 확인하고, 배포를 위한 준비를 마칩니다.",
            "status": "pending",
            "dependencies": [],
            "details": "보고된 주요 버그가 수정되었는지 회귀 테스트를 통해 확인합니다. 프로덕션 배포를 위해 `next build` 스크립트를 실행하고, `.env.production` 파일의 환경 변수(예: `WORDPRESS_API_URL`)가 올바르게 설정되었는지 최종 검토합니다.",
            "testStrategy": "프로덕션 빌드 결과물을 스테이징 환경에 배포하여 최종적으로 동작을 검증한 후, 프로덕션 배포를 승인합니다."
          }
        ]
      },
      {
        "id": 11,
        "title": "백엔드 YouTube 데이터 캐싱 시스템 구축 (MariaDB 기반)",
        "description": "YouTube API 할당량의 효율적 관리를 위해, '/var/www/html/project/mev_home-backend' Express 서버에 데이터 캐싱 시스템을 구축합니다. 이 시스템은 매주 일요일 오후 3시에 YouTube API를 호출하여 영상 데이터를 MariaDB 데이터베이스에 저장하는 역할을 합니다.",
        "details": "저장될 데이터는 영상의 'title'과 'url' 두 가지입니다. 스케줄링 작업(Cron Job)을 설정하여 동기화 프로세스를 자동화해야 합니다. 또한, API 키와 같은 민감 정보는 .env 파일을 통해 안전하게 관리되어야 합니다.",
        "testStrategy": "1. 스케줄링 작업이 매주 일요일 오후 3시에 정확히 실행되는지 서버 로그를 통해 확인합니다. 2. 동기화 작업 후, MariaDB의 관련 테이블에 영상 제목과 URL 데이터가 올바르게 저장되었는지 직접 확인합니다. 3. 의도적으로 잘못된 API 키를 사용하여 API 호출 실패 시, 오류 처리 및 로깅이 정상적으로 동작하는지 검증합니다.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "환경 변수 설정 및 신규 라이브러리 설치",
            "description": "YouTube API 키를 환경 변수로 관리하고, 스케줄링 및 API 호출에 필요한 라이브러리를 설치합니다. 이는 민감 정보 보호와 기능 구현의 기초를 마련합니다.",
            "dependencies": [],
            "details": "1. `/var/www/html/project/mev_home-backend/.env` 파일에 `YOUTUBE_API_KEY`와 동기화할 `YOUTUBE_PLAYLIST_IDS` (쉼표로 구분된 ID 목록)를 추가합니다. `.env.example` 파일도 업데이트합니다.\n2. `npm install axios node-cron` 명령을 실행하여 HTTP 클라이언트(axios)와 스케줄러(node-cron) 라이브러리를 `package.json`에 추가합니다.",
            "status": "done",
            "testStrategy": "1. `process.env.YOUTUBE_API_KEY`를 콘솔에 출력하여 .env 파일이 올바르게 로드되는지 확인합니다.\n2. `package.json` 파일에 `axios`와 `node-cron`이 정상적으로 추가되었는지 확인합니다."
          },
          {
            "id": 2,
            "title": "MariaDB 'youtube_videos' 테이블 생성",
            "description": "YouTube 영상 데이터를 저장할 MariaDB 테이블을 설계하고 생성합니다. 이 테이블은 캐시 데이터의 영구 저장소 역할을 합니다.",
            "dependencies": [],
            "details": "다음 스키마를 가진 `youtube_videos` 테이블 생성 SQL 쿼리를 작성하고 실행합니다.\n- `id`: INT, PRIMARY KEY, AUTO_INCREMENT\n- `playlistId`: VARCHAR(255), NOT NULL\n- `title`: VARCHAR(255), NOT NULL\n- `url`: VARCHAR(255), NOT NULL\n- `syncedAt`: TIMESTAMP, DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP\n`playlistId` 컬럼은 향후 여러 재생목록(주일 설교, 찬양대 등)을 구분하기 위해 필수적입니다.",
            "status": "done",
            "testStrategy": "MariaDB 클라이언트에 접속하여 `DESC youtube_videos;` 명령을 실행하고, 정의된 스키마와 일치하는지 확인합니다."
          },
          {
            "id": 3,
            "title": "YouTube API 데이터 호출 서비스 모듈 구현",
            "description": "YouTube Data API v3를 호출하여 특정 재생목록의 영상 목록(제목, URL)을 가져오는 서비스 모듈을 구현합니다. 이 모듈은 API 통신 로직을 캡슐화하여 재사용성을 높입니다.",
            "dependencies": [
              "11.1"
            ],
            "details": "1. `/var/www/html/project/mev_home-backend/services` 디렉토리를 생성합니다.\n2. `services/youtubeService.js` 파일을 생성합니다.\n3. `axios`를 사용하여 `https://www.googleapis.com/youtube/v3/playlistItems` 엔드포인트를 호출하는 함수를 작성합니다.\n4. 이 함수는 `playlistId`를 인자로 받고, API 응답에서 각 영상의 `title`과 `videoId`를 추출하여 `url` ('https://www.youtube.com/watch?v=' + videoId) 형태로 가공한 객체 배열을 반환해야 합니다.",
            "status": "done",
            "testStrategy": "Node.js 환경에서 `youtubeService.js` 모듈을 직접 실행하여, 유효한 재생목록 ID로 호출 시 영상 데이터 배열이 올바르게 반환되는지 확인합니다."
          },
          {
            "id": 4,
            "title": "데이터베이스 동기화 로직 구현",
            "description": "YouTube API를 통해 가져온 영상 데이터를 MariaDB에 저장하는 함수를 구현합니다. 데이터의 정합성을 위해 기존 데이터를 삭제하고 새로운 데이터로 교체하는 방식을 사용합니다.",
            "dependencies": [
              "11.2",
              "11.3"
            ],
            "details": "1. `/var/www/html/project/mev_home-backend/models` 디렉토리를 생성하고 `youtubeModel.js` 파일을 만듭니다.\n2. `syncYoutubeVideos` 라는 비동기 함수를 작성합니다. 이 함수는 `playlistId`와 영상 데이터 배열을 인자로 받습니다.\n3. 함수 내에서 트랜잭션을 사용하여 다음 작업을 순차적으로 수행합니다:\n    a. `DELETE FROM youtube_videos WHERE playlistId = ?` 쿼리로 해당 재생목록의 기존 데이터를 모두 삭제합니다.\n    b. 전달받은 영상 데이터 배열을 순회하며 `INSERT INTO youtube_videos (playlistId, title, url) VALUES (?, ?, ?)` 쿼리로 새로운 데이터를 삽입합니다.\n4. 이 모듈은 `config/db.js`에 정의된 MariaDB 커넥션 풀을 사용해야 합니다.",
            "status": "done",
            "testStrategy": "테스트용 스크립트를 작성하여 `syncYoutubeVideos` 함수 호출 후, `youtube_videos` 테이블의 데이터가 예상대로 교체되었는지 확인합니다."
          },
          {
            "id": 5,
            "title": "주간 동기화 Cron Job 스케줄러 설정 및 통합",
            "description": "매주 일요일 오후 3시에 데이터 동기화 프로세스를 자동으로 실행하는 Cron Job을 설정합니다. 이를 통해 전체 캐싱 시스템을 자동화하고 완성합니다.",
            "dependencies": [
              "11.4"
            ],
            "details": "1. 메인 파일인 `/var/www/html/project/mev_home-backend/app.js`에 `node-cron`을 import합니다.\n2. `cron.schedule('0 15 * * 0', async () => { ... });` 구문을 사용하여 스케줄을 설정합니다. (KST 기준, 서버 시간대에 따라 UTC 조정 필요)\n3. 스케줄된 작업 내에서 `.env`에 정의된 `YOUTUBE_PLAYLIST_IDS`를 읽어와 각 ID에 대해 다음을 반복 실행합니다:\n    a. `youtubeService.js`의 함수를 호출하여 영상 데이터를 가져옵니다.\n    b. `youtubeModel.js`의 `syncYoutubeVideos` 함수를 호출하여 DB에 데이터를 동기화합니다.\n4. 동기화 시작, 성공, 실패 시점에 대한 로그를 `console.log` 또는 `console.error`를 사용하여 기록하여 모니터링이 용이하도록 합니다.",
            "status": "done",
            "testStrategy": "1. 테스트를 위해 Cron 스케줄을 1분 후로 임시 변경하여 서버를 실행하고, 1분 뒤 동기화 로그가 정상적으로 출력되는지 확인합니다.\n2. 작업 완료 후 MariaDB의 `youtube_videos` 테이블 데이터가 최신 상태로 업데이트되었는지 검증합니다.\n3. 최종적으로 스케줄을 '0 15 * * 0'으로 복원합니다."
          }
        ]
      },
      {
        "id": 12,
        "title": "캐시된 YouTube 데이터 제공 API 엔드포인트 개발",
        "description": "프론트엔드에서 사용할 수 있도록, '/var/www/html/project/mev_home-backend' Express 서버에 캐시된 YouTube 영상 목록을 제공하는 API 엔드포인트를 개발합니다.",
        "details": "API 규격은 다음과 같습니다: 1. 엔드포인트: GET /api/youtube-videos 2. 요청 파라미터: playlistId (예: /api/youtube-videos?playlistId=...) 3. 성공 응답: MariaDB에서 조회한 영상 목록을 JSON 배열 형태로 반환합니다. 각 객체는 'title'과 'url' 키를 포함해야 합니다. (예: [{ \\\"title\\\": \\\"영상 제목\\\", \\\"url\\\": \\\"...\\\" }])",
        "testStrategy": "1. API 클라이언트(Postman 등)를 사용하여 유효한 playlistId로 API를 호출했을 때, 200 OK 상태 코드와 함께 올바른 JSON 형식의 데이터가 반환되는지 확인합니다. 2. playlistId를 누락하거나 유효하지 않은 ID로 요청했을 때, 400 Bad Request와 같은 적절한 에러 코드가 반환되는지 확인합니다. 3. DB에 존재하지 않는 playlistId로 요청 시, 404 Not Found 에러가 반환되는지 확인합니다.",
        "status": "done",
        "dependencies": [
          11
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "GET /api/youtube-videos 라우트 설정",
            "description": "Express 서버에 새로운 API 엔드포인트인 GET /api/youtube-videos를 위한 라우트 파일을 생성하고, 메인 라우터에 등록합니다.",
            "dependencies": [],
            "details": "1. `/var/www/html/project/mev_home-backend/routes/api/` 디렉토리에 `youtube.js` 파일을 새로 생성합니다.\n2. `youtube.js` 파일 내에서 Express의 `Router`를 사용하여 `GET /` 경로를 정의하고, 아직 생성되지 않은 `youtubeController.getVideosByPlaylist` 함수를 핸들러로 지정합니다.\n3. `/var/www/html/project/mev_home-backend/routes/api/index.js` 파일을 수정하여 `/youtube-videos` 경로 요청이 `youtube.js` 라우터를 사용하도록 미들웨어를 추가합니다. (예: `router.use('/youtube-videos', youtubeRoutes);`)",
            "status": "done",
            "testStrategy": "서버를 실행한 후, `GET /api/youtube-videos`로 요청 시 501 Not Implemented 또는 컨트롤러 함수가 없다는 에러가 발생하는지 확인하여 라우팅이 연결되었는지 검증합니다."
          },
          {
            "id": 2,
            "title": "youtubeController 기본 구조 및 요청 파라미터 유효성 검사 구현",
            "description": "API 요청의 비즈니스 로직을 담당할 컨트롤러 파일을 생성하고, 요청 파라미터(playlistId)를 수신하고 유효성을 검사하는 기본 로직을 구현합니다.",
            "dependencies": [
              "12.1"
            ],
            "details": "1. `/var/www/html/project/mev_home-backend/controllers/` 디렉토리에 `youtubeController.js` 파일을 생성합니다.\n2. `getVideosByPlaylist`라는 이름의 비동기 함수를 생성하고 `module.exports`에 추가합니다.\n3. 함수 내에서 `req.query`로부터 `playlistId`를 추출합니다.\n4. `playlistId`가 제공되지 않았을 경우, 400 Bad Request 상태 코드와 함께 'playlistId is required'와 같은 에러 메시지를 JSON 형식으로 응답하는 로직을 추가합니다.",
            "status": "done",
            "testStrategy": "Postman을 사용하여 `GET /api/youtube-videos` (playlistId 없음) 요청 시 400 에러가 반환되는지 확인합니다. `GET /api/youtube-videos?playlistId=someId` 요청 시에는 (아직 DB 로직이 없으므로) 응답이 없거나 다음 단계의 로직이 실행되는지 확인합니다."
          },
          {
            "id": 3,
            "title": "MariaDB 연동 및 데이터 조회 로직 구현",
            "description": "컨트롤러 함수 내에서 MariaDB에 연결하여, 주어진 `playlistId`에 해당하는 캐시된 YouTube 영상 목록을 데이터베이스에서 조회하는 로직을 구현합니다.",
            "dependencies": [
              "12.2"
            ],
            "details": "1. `youtubeController.js` 파일에 기존에 구현된 데이터베이스 커넥션 모듈(예: `config/db.js`)을 import합니다.\n2. `getVideosByPlaylist` 함수 내에서 `playlistId`를 사용하여 데이터베이스를 쿼리합니다.\n3. Task 11에서 생성된 테이블(예: `youtube_videos`)을 대상으로 `SELECT title, url FROM youtube_videos WHERE playlist_id = ?` 와 같은 SQL 쿼리를 실행합니다. SQL Injection을 방지하기 위해 반드시 Prepared Statement를 사용합니다.",
            "status": "done",
            "testStrategy": "컨트롤러 코드에 임시로 유효한 `playlistId`를 하드코딩하고, DB에서 올바른 데이터를 가져오는지 `console.log`로 확인합니다."
          },
          {
            "id": 4,
            "title": "성공 응답 및 에러 처리 로직 완성",
            "description": "데이터베이스 조회 결과를 바탕으로 성공 응답(200 OK), 데이터 없음(404 Not Found), 서버 오류(500 Internal Server Error) 등 다양한 시나리오에 대한 응답 처리 로직을 완성합니다.",
            "dependencies": [
              "12.3"
            ],
            "details": "1. `youtubeController.js`의 `getVideosByPlaylist` 함수를 수정합니다.\n2. DB 조회에 성공하고 결과 데이터가 있는 경우, 200 OK 상태 코드와 함께 조회된 영상 목록(객체 배열)을 JSON 형식으로 응답합니다.\n3. DB 조회는 성공했으나 결과 데이터가 없는 경우(빈 배열), 404 Not Found 상태 코드와 함께 'No videos found for the given playlistId'와 같은 메시지를 응답합니다.\n4. 데이터베이스 쿼리 실행 중 예외(exception)가 발생하면, `try...catch` 블록으로 에러를 잡아 서버 콘솔에 에러를 로깅하고 500 Internal Server Error 상태 코드를 응답합니다.",
            "status": "done",
            "testStrategy": "Postman을 사용하여 DB에 존재하는 `playlistId`와 존재하지 않는 `playlistId`로 각각 요청을 보내 200 응답과 404 응답이 올바르게 반환되는지 확인합니다. DB 연결을 일시적으로 끊고 요청을 보내 500 에러가 발생하는지 확인합니다."
          },
          {
            "id": 5,
            "title": "API 엔드포인트 통합 테스트 및 코드 정리",
            "description": "개발된 API 엔드포인트의 전체적인 동작을 Postman과 같은 도구를 사용하여 최종 검증하고, 코드 가독성을 높이기 위해 주석 추가 및 코드 포맷팅을 진행합니다.",
            "dependencies": [
              "12.4"
            ],
            "details": "1. Postman을 사용하여 Task의 'Test Strategy'에 명시된 모든 테스트 케이스를 실행합니다.\n   - 유효한 `playlistId` 요청 → 200 OK, JSON 배열 반환 확인\n   - `playlistId` 누락 요청 → 400 Bad Request 확인\n   - 존재하지 않는 `playlistId` 요청 → 404 Not Found 확인\n2. `youtube.js` 라우트 파일과 `youtubeController.js` 컨트롤러 파일에 JSDoc 형식의 주석을 추가하여 각 파일과 함수의 역할을 명확히 설명합니다.\n3. 프로젝트의 코드 스타일 가이드(ESLint 등)에 맞춰 코드를 포맷팅하고 불필요한 `console.log` 문을 제거합니다.",
            "status": "done",
            "testStrategy": "모든 테스트 케이스가 예상대로 통과하는 것을 최종 확인하고, 코드 리뷰를 통해 다른 팀원이 코드를 쉽게 이해할 수 있는지 검증합니다."
          }
        ]
      },
      {
        "id": 13,
        "title": "단일 게시물 보기 구현",
        "description": "BoardPage에서 게시물 제목을 클릭하면 단일 WordPress 게시물의 전체 내용을 표시하는 전용 페이지를 개발합니다.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          5
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "단일 게시물 보기 구현",
        "description": "BoardPage에서 게시물 제목을 클릭하면 단일 WordPress 게시물의 전체 내용을 표시하는 전용 페이지를 개발합니다.",
        "details": "하위 작업:\n1. 단일 게시물 페이지 컴포넌트 생성: ID를 기반으로 단일 게시물의 전체 내용을 가져와 표시하는 새 React 컴포넌트(예: SinglePostPage.jsx)를 개발합니다.\n2. 단일 게시물 라우트 추가: React Router를 구성하여 SinglePostPage 컴포넌트를 렌더링하는 단일 게시물에 대한 동적 라우트(예: /news/:postId)를 포함합니다.\n3. 탐색을 위한 PostListItem 수정: PostListItem 컴포넌트를 업데이트하여 게시물 제목을 클릭 가능하게 만들고, react-router-dom을 사용하여 해당 단일 게시물 페이지로 이동합니다.\n4. 단일 게시물 API 가져오기 구현: src/api/wordpress.js에 ID로 단일 WordPress 게시물을 가져오는 새 함수(예: getPostById)를 추가합니다.\n5. 단일 게시물 페이지에 API 통합: SinglePostPage.jsx 내에서 getPostById 함수를 사용하여 게시물 내용을 가져와 표시합니다.\n6. 단일 게시물 페이지 기본 스타일링: SinglePostPage에 기본 스타일을 적용하여 게시물 내용의 가독성과 깔끔한 표시를 보장합니다.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "통합 테스트를 위한 상세 사용자 시나리오 및 예외 케이스 정의",
        "description": "이해관계자와 협력하여 WordPress, YouTube 및 디자인 개선을 위한 포괄적인 사용자 시나리오 및 예외 케이스를 정의하여 테스트 범위를 확장합니다.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "주요 페이지에 대한 성능 벤치마크(LCP, TTI) 설정",
        "description": "주요 웹사이트 페이지에 대한 LCP 및 TTI 지표의 특정 목표 값을 조사하고 정의하여 성능 테스트를 안내합니다.",
        "details": "",
        "testStrategy": "",
        "status": "cancelled",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "오류 처리 UI/UX 및 메시지 디자인",
        "description": "API 실패(WordPress, YouTube) 및 콘텐츠 없음 시나리오와 관련된 모든 오류 메시지에 대한 정확한 문구, 스타일 및 사용자 경험을 정의합니다.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "YouTube 데이터에 대한 백엔드 캐싱 검증 전략 개발",
        "description": "YouTube 재생목록 데이터에 대한 일일 백엔드 캐싱 메커니즘을 검증하는 데 필요한 기술 단계 및 도구를 설명합니다.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "UI 검증을 위한 상세 디자인 목업/스타일 가이드 확보/생성",
        "description": "테스트 중 정확한 UI 일관성 검사를 가능하게 하는 상세 디자인 목업 또는 포괄적인 스타일 가이드를 확보하거나 개발합니다.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "WordPress 및 YouTube를 위한 포괄적인 테스트 데이터 준비",
        "description": "WordPress에 필요한 모든 테스트 콘텐츠(게시물, 미디어, 카테고리)를 생성하고 구성하며, YouTube 채널에 철저한 통합 테스트를 위한 적절한 재생목록/동영상이 있는지 확인합니다.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "QA 체크리스트 관리 도구/프로세스 선택 및 구현",
        "description": "QA 체크리스트를 효과적으로 관리, 실행 및 추적하기 위한 적합한 도구 또는 프로세스를 선택하고 설정합니다.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-31T02:52:25.742Z",
      "updated": "2025-09-13T11:52:50.806Z",
      "description": "Tasks for phase-2 context"
    }
  }
}