{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "기본 레이아웃 개선 및 라우팅 최적화",
        "description": "기존 프로젝트의 레이아웃(헤더, 푸터, 네비게이션)을 보완하고, 라우팅 시스템을 최적화합니다. PRD에 명시된 링크들을 확인하여 업데이트하고, 반응형 디자인을 강화하여 전반적인 UI/UX를 개선합니다.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "- 기존 헤더, 푸터, 네비게이션 컴포넌트 리팩토링 및 기능 보완\n- 라우팅 구조 최적화 (예: 코드 스플리팅, 레이지 로딩 적용)\n- PRD 기반 네비게이션 링크 최신화\n- 모바일 및 태블릿 환경 대응을 위한 반응형 디자인 강화",
        "testStrategy": "최적화된 라우팅 시스템이 정상적으로 동작하는지 확인합니다. 업데이트된 네비게이션 링크가 정확한 페이지로 연결되는지 검증하고, 다양한 디바이스 및 화면 크기에서 개선된 반응형 레이아웃이 깨짐 없이 표시되는지 테스트합니다.",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "환영 및 교회 소개 페이지 내용 추가 및 수정",
        "description": "기존 '환영 및 교회 소개' 페이지들(인사말, 교회 비전, 섬기는 사람들)에 PRD에 명시된 내용을 추가하고 수정합니다.",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "medium",
        "details": "- 인사말 페이지: 담임목사 사진(오른쪽)과 3문단 텍스트 배치\n- 교회 비전 페이지: 3가지 비전을 설명하는 콘텐츠 페이지 구현\n- 섬기는 사람들 페이지: 추후 조직도 이미지를 쉽게 추가할 수 있는 기본 틀 제공",
        "testStrategy": "각 페이지의 콘텐츠와 레이아웃이 PRD의 명세와 일치하는지 시각적으로 확인합니다.",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "교회 연혁 타임라인 UI 개발",
        "description": "기존 '교회 연혁' 페이지에 50주년 역사를 보여주는 타임라인 형태의 UI를 구현합니다.",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "medium",
        "details": "사용자가 스크롤하며 시간 순서에 따라 주요 연혁을 확인할 수 있는 인터랙티브 타임라인 컴포넌트를 개발합니다.",
        "testStrategy": "타임라인 UI가 디자인 시안에 맞게 구현되었는지 확인하고, 다양한 디바이스에서 반응형으로 동작하는지 테스트합니다.",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "교회학교 페이지 콘텐츠 추가",
        "description": "기존 '교회학교' 페이지들(유아부, 아동부, 중고등부, 청년부)에 각 부서별 간단한 소개와 소식을 담을 수 있는 정적 콘텐츠를 추가합니다.",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "low",
        "details": "유아부, 아동부, 중고등부, 청년부 각 페이지에 부서 소개와 소식을 담은 정적 콘텐츠를 추가합니다.",
        "testStrategy": "각 부서별 페이지에 추가된 콘텐츠가 올바르게 표시되는지 확인하고, 네비게이션을 통해 정상적으로 접근 가능한지 검증합니다.",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "YouTube API 연동 백엔드 서비스 구축",
        "description": "YouTube Data API v3를 사용하여 지정된 재생목록의 영상 정보를 주기적으로 가져오는 백엔드 서버 구축이 완료되었습니다. 현재 서버는 PM2를 통해 실행 중입니다.",
        "status": "done",
        "dependencies": [],
        "priority": "low",
        "details": "- API 키를 안전하게 관리\n- '주일 설교', '찬양대', '특별 찬양' 재생목록 ID를 기반으로 영상 목록(제목, 썸네일, 영상 ID)을 가져오는 로직 구현\n- 프론트엔드에 데이터를 제공할 API 엔드포인트 생성\n- 주기적인 데이터 동기화를 위한 스케줄러(예: cron job) 설정",
        "testStrategy": "백엔드 서버가 지정된 주기로 YouTube 재생목록을 성공적으로 동기화하는지 로그를 통해 확인하고, API 엔드포인트가 올바른 데이터를 반환하는지 테스트합니다.",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "주일 말씀 페이지 프론트엔드 개발",
        "description": "백엔드에서 제공하는 YouTube 영상 데이터를 받아 '주일 설교', '찬양대', '특별 찬양' 목록을 화면에 표시하는 UI를 개발하고, 백엔드 API와 통신하기 위한 프론트엔드 API 클라이언트 모듈을 구현합니다.",
        "status": "done",
        "dependencies": [
          1,
          5
        ],
        "priority": "low",
        "details": "사용자가 각 카테고리별 영상 목록을 보고, 썸네일을 클릭하여 영상을 시청할 수 있는 인터페이스를 구현합니다. 백엔드 API와 통신하기 위한 API 클라이언트 모듈(예: Axios, Fetch API 래퍼)을 구현하여 데이터 요청 및 상태 관리를 처리합니다. YouTube에 새 영상이 추가되면 웹사이트에 자동으로 반영되어야 합니다.",
        "testStrategy": "백엔드 API(Task 5)와 연동하여 영상 목록이 정상적으로 표시되는지 확인합니다. API 클라이언트 모듈이 백엔드 엔드포인트와 정상적으로 통신하고 응답 데이터를 올바르게 파싱하는지 검증합니다. YouTube 재생목록에 영상을 추가/삭제했을 때 웹사이트에 반영되는지 테스트합니다.",
        "subtasks": [
          {
            "id": 1,
            "title": "",
            "description": "백엔드 API 연동을 위한 클라이언트 모듈 구현",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "",
            "description": "영상 목록 UI 컴포넌트 개발 ('주일 설교', '찬양대', '특별 찬양')",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 7,
        "title": "교회 소식 UI 컴포넌트 개발 (갤러리 형태)",
        "description": "기존 '교회 소식' 페이지에 교회 행사 사진 등을 표시할 갤러리 형태의 게시판 UI 컴포넌트를 구현합니다. 추후 Headless WordPress REST API와 연동될 것을 대비한 UI 템플릿입니다.",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "medium",
        "details": "이미지 썸네일 그리드 레이아웃을 구현합니다. API 연동 자체는 현재 범위에 포함되지 않으며, 목업(mock) 데이터로 UI를 개발합니다.",
        "testStrategy": "정적(목업) 데이터를 사용하여 갤러리 레이아웃이 디자인 명세에 맞게 표시되는지 확인합니다.",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "주보 페이지 UI 컴포넌트 개발 (분할 화면)",
        "description": "기존 '주보' 페이지에 좌/우 분할 화면 레이아웃을 구현합니다. 오른쪽에는 역대 주보 제목 목록을, 왼쪽에는 선택된 주보 이미지를 표시합니다. Headless WordPress 연동을 위한 UI 템플릿입니다.",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "medium",
        "details": "목업 데이터로 UI를 개발합니다.",
        "testStrategy": "목업 데이터를 사용하여 목록에서 항목을 선택했을 때 왼쪽 화면의 이미지가 올바르게 변경되는지 테스트합니다. 레이아웃이 다양한 화면 크기에서 유지되는지 확인합니다.",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "자유 게시판 UI 컴포넌트 개발 (읽기 전용)",
        "description": "기존 '자유 게시판' 페이지에 읽기 전용 기능을 가진 기본 UI를 구현합니다. (현재는 읽기 전용 기능만 구현)",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "low",
        "details": "게시글 목록과 본문을 볼 수 있는 간단한 인터페이스를 제공합니다. 쓰기/수정/삭제 기능은 포함하지 않습니다.",
        "testStrategy": "목업 데이터를 사용하여 게시글 목록과 상세 내용이 정상적으로 표시되는지 확인합니다.",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "최종 통합 및 배포 준비",
        "description": "개발된 모든 기능들을 통합하고, 최종 테스트를 거쳐 프로덕션 환경에 배포할 준비를 합니다.",
        "details": "- 전체 기능에 대한 QA(품질 보증) 수행\n- 빌드 및 배포 스크립트 작성\n- 프로덕션 환경 변수 설정",
        "testStrategy": "스테이징 환경에서 모든 기능이 요구사항대로 동작하는지 최종 검증합니다. 실제 배포 절차를 시뮬레이션합니다.",
        "priority": "high",
        "dependencies": [
          2,
          3,
          4,
          6,
          9
        ],
        "status": "done",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-30T19:28:17.619Z",
      "updated": "2025-08-31T02:50:47.300Z",
      "description": "Tasks for master context"
    }
  },
  "phase-2": {
    "tasks": [
      {
        "id": 1,
        "title": "공용 '히어로 배너' 컴포넌트 개발 (Develop Reusable 'Hero Banner' Component)",
        "description": "각 서브 페이지 상단에 공통으로 사용될 '히어로 배너' UI 컴포넌트를 개발합니다. 이를 통해 페이지의 시각적 통일성과 정보 전달력을 높입니다.",
        "details": "배경 이미지 URL과 페이지 제목 텍스트를 props로 받아 동적으로 콘텐츠를 표시해야 합니다. 반응형 디자인을 적용하여 데스크톱과 모바일 환경 모두에서 최적화된 형태로 보여야 합니다.",
        "testStrategy": "Storybook과 같은 UI 개발 도구를 사용하여 다양한 이미지와 텍스트 길이에 대한 컴포넌트의 렌더링을 테스트합니다. 브라우저 개발자 도구의 기기 에뮬레이션 기능으로 반응형 동작을 검증합니다.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "컴포넌트 기본 구조 및 Props 정의 (Define Component's Basic Structure and Props)",
            "description": "'HeroBanner' 컴포넌트 파일을 생성하고, 배경 이미지 URL과 페이지 제목을 받을 수 있도록 props 인터페이스를 정의합니다. 기본적인 JSX/HTML 마크업 구조를 작성합니다.",
            "dependencies": [],
            "details": "React/Vue 컴포넌트 파일(.tsx, .vue 등)을 생성합니다. TypeScript를 사용하는 경우, `backgroundImageUrl: string`과 `pageTitle: string`을 포함하는 props 타입을 정의합니다. 시맨틱 마크업을 고려하여 외부 컨테이너와 내부 제목 요소(예: <h1>)로 구성된 기본 골격을 만듭니다.",
            "status": "pending",
            "testStrategy": "컴포넌트가 에러 없이 렌더링되고, 하드코딩된 기본 props 값이 화면에 표시되는지 확인합니다."
          },
          {
            "id": 2,
            "title": "데스크톱 버전 기본 스타일링 적용 (Apply Basic Styling for Desktop Version)",
            "description": "CSS(또는 CSS-in-JS)를 사용하여 데스크톱 화면 크기를 기준으로 히어로 배너의 기본 스타일을 구현합니다. props로 받은 배경 이미지를 적용하고, 페이지 제목 텍스트의 스타일을 디자인 시안에 맞게 조정합니다.",
            "dependencies": [],
            "details": "배경 이미지가 배너 영역을 가득 채우도록 `background-size: cover`, `background-position: center` 등의 속성을 적용합니다. 제목 텍스트가 이미지 위에서 잘 보이도록 적절한 폰트 색상, 크기, 그림자 효과(text-shadow) 등을 추가하고 중앙에 배치합니다.\n<info added on 2025-08-31T05:38:42.823Z>\n'부드러운 느낌'을 주기 위해 `sans-serif` 계열 폰트를 사용하고, 제목과 부제목은 함께 중앙 정렬합니다. 텍스트 가독성을 높이기 위해 그림자 효과는 은은하게 적용합니다.\n</info added on 2025-08-31T05:38:42.823Z>",
            "status": "pending",
            "testStrategy": "지정된 이미지 URL이 배경으로 올바르게 표시되는지, 텍스트 스타일이 디자인과 일치하는지 시각적으로 검토합니다."
          },
          {
            "id": 3,
            "title": "반응형 디자인 구현 (모바일 뷰 최적화) (Implement Responsive Design for Mobile Optimization)",
            "description": "미디어 쿼리를 사용하여 모바일 화면 크기에서 히어로 배너의 레이아웃과 스타일이 최적화되도록 조정합니다. 배너의 높이, 텍스트 크기, 여백 등을 모바일 환경에 맞게 수정합니다.",
            "dependencies": [],
            "details": "일반적인 모바일 브레이크포인트(예: 768px)를 기준으로 미디어 쿼리를 작성합니다. 작은 화면에서 배너의 높이를 줄이고, 제목 텍스트의 크기를 조정하여 가독성을 확보합니다.",
            "status": "pending",
            "testStrategy": "브라우저 개발자 도구의 기기 에뮬레이션 기능을 사용하여 다양한 모바일 화면 크기에서 레이아웃이 깨지지 않고 콘텐츠가 명확하게 보이는지 확인합니다."
          },
          {
            "id": 4,
            "title": "Storybook 연동 및 다양한 Props 케이스 테스트 (Integrate with Storybook and Test Prop Variations)",
            "description": "Storybook에 'HeroBanner' 컴포넌트를 등록하고, 다양한 케이스를 테스트할 수 있는 스토리를 작성합니다. 짧은 제목, 매우 긴 제목, 여러 종류의 배경 이미지를 props로 전달하여 각 상황에서 컴포넌트가 의도대로 렌더링되는지 확인합니다.",
            "dependencies": [],
            "details": "컴포넌트에 대한 `.stories.tsx` 파일을 생성합니다. 기본 상태, 긴 텍스트 상태, 특정 이미지 비율 상태 등 최소 3개 이상의 스토리를 작성하여 엣지 케이스를 시각적으로 테스트하고 문서화합니다.",
            "status": "pending",
            "testStrategy": "작성된 각 스토리가 Storybook UI에서 정상적으로 렌더링되는지 확인하고, 컨트롤(Controls) 애드온을 통해 실시간으로 props를 변경하며 UI 변화를 테스트합니다."
          },
          {
            "id": 5,
            "title": "코드 리뷰, 문서화 및 최종 검수 (Code Review, Documentation, and Final Verification)",
            "description": "작성된 컴포넌트 코드의 가독성과 재사용성을 검토하고, 다른 개발자가 쉽게 사용할 수 있도록 props 사용법에 대한 간단한 주석이나 문서를 추가합니다. 최종적으로 모든 요구사항이 충족되었는지 검수합니다.",
            "dependencies": [],
            "details": "컴포넌트 상단에 JSDoc 형식으로 컴포넌트의 역할과 각 prop에 대한 설명을 추가합니다. 불필요한 코드를 제거하고 변수명을 명확하게 수정합니다. PR(Pull Request)을 생성하여 동료의 코드 리뷰를 요청합니다.\n<info added on 2025-08-31T05:40:23.693Z>\n또한, `subtitle`이나 `CTA 버튼`과 같은 선택적(optional) props의 사용법을 다른 개발자가 쉽게 이해하고 활용할 수 있도록 사용 예시를 포함한 문서를 보강합니다. 최종적으로 상위 태스크의 모든 요구사항이 충족되었는지 검수합니다.\n</info added on 2025-08-31T05:40:23.693Z>",
            "status": "pending",
            "testStrategy": "원래 태스크의 요구사항(props, 반응형)과 테스트 전략(Storybook, 브라우저 에뮬레이션)이 모두 충족되었는지 체크리스트를 통해 최종 확인합니다."
          }
        ]
      },
      {
        "id": 2,
        "title": "콘텐츠 페이드인 애니메이션 효과 구현 (Implement Content Fade-in Animation)",
        "description": "페이지 로드 및 스크롤 시 콘텐츠가 부드럽게 나타나는 '페이드인' 효과를 적용하여 세련된 사용자 경험을 제공합니다.",
        "details": "Intersection Observer API 또는 관련 라이브러리(예: framer-motion)를 사용하여, 뷰포트에 진입하는 콘텐츠 요소에 애니메이션 효과를 적용합니다. 재사용이 가능하도록 커스텀 훅(Hook) 또는 고차 컴포넌트(HOC) 형태로 구현합니다.",
        "testStrategy": "여러 페이지에 적용하여 스크롤 시 애니메이션이 부드럽고 자연스럽게 동작하는지 확인합니다. Lighthouse와 같은 성능 측정 도구를 사용하여 애니메이션으로 인한 성능 저하가 없는지 검증합니다.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "애니메이션 구현 기술 선정 및 설계",
            "description": "Intersection Observer API와 framer-motion 라이브러리의 장단점을 비교 분석하여 프로젝트에 가장 적합한 기술을 선정하고, 이를 기반으로 재사용 가능한 커스텀 훅의 인터페이스(입력 props, 반환 값)를 설계합니다.",
            "dependencies": [],
            "details": "주요 평가 기준은 성능, 번들 크기, 개발 편의성입니다. 최종적으로 선택된 기술과 설계된 훅의 API 명세를 간단히 문서화합니다.",
            "status": "pending",
            "testStrategy": "각 기술의 기본 예제를 프로토타이핑하여 성능(CPU 사용량, 프레임 드랍)을 비교 측정합니다."
          },
          {
            "id": 2,
            "title": "가시성 감지 커스텀 훅(useVisibility) 구현",
            "description": "선정된 기술(예: Intersection Observer API)을 사용하여, 특정 DOM 요소가 뷰포트에 진입했는지 여부를 감지하는 핵심 로직을 커스텀 훅으로 구현합니다.",
            "dependencies": [
              "2.1"
            ],
            "details": "훅은 감시할 요소에 부착할 ref 객체와 요소의 현재 가시성 상태(boolean)를 반환해야 합니다. 한 번 화면에 나타난 요소는 더 이상 감시하지 않도록 최적화 옵션을 포함합니다.",
            "status": "pending",
            "testStrategy": "Jest와 React Testing Library를 사용하여 훅이 요소의 가시성 상태 변화를 정확히 반환하는지 단위 테스트를 작성합니다."
          },
          {
            "id": 3,
            "title": "페이드인 효과를 위한 CSS 스타일 정의",
            "description": "애니메이션의 시작(보이지 않는 상태)과 끝(보이는 상태)을 정의하는 CSS 클래스 또는 스타일을 작성합니다. 부드러운 전환 효과를 위해 transition 속성을 설정합니다.",
            "dependencies": [],
            "details": "초기 상태는 `opacity: 0`, `transform: translateY(20px)` 등으로 설정하고, 최종 상태는 `opacity: 1`, `transform: translateY(0)`으로 설정합니다. CSS Modules 또는 Styled-components를 사용하여 스타일을 캡슐화합니다.",
            "status": "pending",
            "testStrategy": "정적 HTML 페이지에서 정의된 CSS 클래스를 요소에 토글하며 전환 효과가 의도대로 작동하는지 시각적으로 확인합니다."
          },
          {
            "id": 4,
            "title": "재사용 가능한 애니메이션 래퍼 컴포넌트(FadeIn) 개발",
            "description": "구현된 `useVisibility` 훅과 CSS 스타일을 결합하여, 자식 컴포넌트(children)를 감싸기만 하면 페이드인 효과가 적용되는 `FadeIn` 래퍼 컴포넌트를 개발합니다.",
            "dependencies": [
              "2.2",
              "2.3"
            ],
            "details": "이 컴포넌트는 내부적으로 `useVisibility` 훅을 호출하고, 반환된 가시성 상태에 따라 자식 요소에 동적으로 CSS 클래스를 적용합니다. 애니메이션 지연(delay), 강도(intensity) 등을 props로 제어할 수 있도록 구현합니다.\n<info added on 2025-08-31T05:42:49.891Z>\n사용자가 스크롤하여 화면 밖으로 나갔다가 다시 들어올 때마다 애니메이션이 반복 실행되도록 로직을 구현합니다.\n</info added on 2025-08-31T05:42:49.891Z>",
            "status": "pending",
            "testStrategy": "Storybook을 사용하여 `FadeIn` 컴포넌트의 다양한 props(delay, direction 등)가 올바르게 동작하는지 시각적으로 테스트하고 문서화합니다."
          },
          {
            "id": 5,
            "title": "샘플 페이지 적용 및 애니메이션 미세 조정",
            "description": "임시 테스트 페이지를 만들어 다양한 종류의 콘텐츠(텍스트 블록, 이미지, 카드 리스트)에 `FadeIn` 컴포넌트를 적용하고, 실제 사용 환경에서 어떻게 보이는지 검증합니다.",
            "dependencies": [
              "2.4"
            ],
            "details": "스크롤 시 애니메이션의 시작 타이밍, 지속 시간, 이징(easing) 함수 등을 조정하여 가장 자연스럽고 세련된 사용자 경험을 제공하도록 값을 미세 조정합니다.\n<info added on 2025-08-31T05:43:37.280Z>\n애니메이션의 `transition-duration` 값을 조정하여, 사용자가 가장 편안하고 자연스럽게 느낄 수 있는 최적의 속도를 찾습니다.\n</info added on 2025-08-31T05:43:37.280Z>",
            "status": "pending",
            "testStrategy": "여러 브라우저(Chrome, Firefox, Safari)와 디바이스(데스크톱, 모바일)에서 스크롤하며 애니메이션이 끊김 없이 부드럽게 동작하는지 교차 검증합니다."
          }
        ]
      },
      {
        "id": 3,
        "title": "10개 주요 페이지에 공통 디자인(배너, 애니메이션) 적용 (Apply Common Design to 10 Pages)",
        "description": "개발된 배너 컴포넌트와 페이드인 애니메이션을 PRD에 명시된 10개의 페이지에 통합 적용합니다.",
        "details": "적용 대상 페이지: 환영합니다(4), 교회소개(2), 교회학교(4). 각 페이지의 주제에 맞는 배너 이미지와 제목을 설정하고, 주요 콘텐츠 블록에 스크롤 애니메이션 효과를 적용합니다.",
        "testStrategy": "지정된 10개 페이지를 모두 방문하여 배너가 올바르게 표시되는지, 스크롤 애니메이션이 정상적으로 작동하는지 시각적으로 검수합니다. 페이지 간 이동 시에도 일관된 경험을 제공하는지 확인합니다.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "10개 페이지 배너 콘텐츠(이미지, 제목) 수집 및 정리",
            "description": "적용 대상인 10개 페이지(환영합니다 4, 교회소개 2, 교회학교 4) 각각의 주제에 맞는 배너 이미지와 제목 텍스트를 PRD를 기반으로 확정하고, 필요한 에셋을 준비합니다.",
            "dependencies": [],
            "details": "각 페이지의 정체성을 나타낼 수 있는 고품질 이미지를 선정하고, 제목 텍스트를 최종 결정합니다. 이미지 파일은 웹에 최적화된 포맷과 크기로 준비해야 합니다.\n<info added on 2025-08-31T05:44:44.389Z>\n실제 콘텐츠가 준비되기 전까지 개발을 진행할 수 있도록, 각 페이지의 주제에 맞는 고품질 임시 스톡 이미지와 제목/부제목 문구를 우선 적용하여 전체적인 UI 구조를 완성합니다.\n</info added on 2025-08-31T05:44:44.389Z>",
            "status": "pending",
            "testStrategy": "준비된 이미지와 텍스트 목록이 PRD의 요구사항 및 각 페이지의 콘텐츠와 일치하는지 검토합니다."
          },
          {
            "id": 2,
            "title": "'환영합니다' 카테고리 4개 페이지에 디자인 적용",
            "description": "'환영합니다' 카테고리에 속한 4개의 페이지에 개발된 '히어로 배너' 컴포넌트와 페이드인 애니메이션을 통합 적용합니다.",
            "dependencies": [
              "3.1"
            ],
            "details": "각 페이지의 최상단에 배너 컴포넌트를 추가하고, 1번 서브태스크에서 준비한 이미지와 제목을 props로 전달합니다. 페이지의 주요 콘텐츠 블록에 스크롤 기반 페이드인 애니메이션을 적용합니다.",
            "status": "pending",
            "testStrategy": "해당 4개 페이지를 브라우저에서 직접 확인하여 배너가 올바른 콘텐츠로 표시되는지, 스크롤 시 애니메이션이 정상 작동하는지 시각적으로 검수합니다."
          },
          {
            "id": 3,
            "title": "'교회소개' 카테고리 2개 페이지에 디자인 적용",
            "description": "'교회소개' 카테고리에 속한 2개의 페이지에 개발된 '히어로 배너' 컴포넌트와 페이드인 애니메이션을 통합 적용합니다.",
            "dependencies": [
              "3.1"
            ],
            "details": "각 페이지의 최상단에 배너 컴포넌트를 추가하고, 1번 서브태스크에서 준비한 이미지와 제목을 props로 전달합니다. 페이지의 주요 콘텐츠 블록에 스크롤 기반 페이드인 애니메이션을 적용합니다.",
            "status": "pending",
            "testStrategy": "해당 2개 페이지를 브라우저에서 직접 확인하여 배너가 올바른 콘텐츠로 표시되는지, 스크롤 시 애니메이션이 정상 작동하는지 시각적으로 검수합니다."
          },
          {
            "id": 4,
            "title": "'교회학교' 카테고리 4개 페이지에 디자인 적용",
            "description": "'교회학교' 카테고리에 속한 4개의 페이지에 개발된 '히어로 배너' 컴포넌트와 페이드인 애니메이션을 통합 적용합니다.",
            "dependencies": [
              "3.1"
            ],
            "details": "각 페이지의 최상단에 배너 컴포넌트를 추가하고, 1번 서브태스크에서 준비한 이미지와 제목을 props로 전달합니다. 페이지의 주요 콘텐츠 블록에 스크롤 기반 페이드인 애니메이션을 적용합니다.",
            "status": "pending",
            "testStrategy": "해당 4개 페이지를 브라우저에서 직접 확인하여 배너가 올바른 콘텐츠로 표시되는지, 스크롤 시 애니메이션이 정상 작동하는지 시각적으로 검수합니다."
          },
          {
            "id": 5,
            "title": "10개 페이지 전체 통합 검수 및 반응형 테스트",
            "description": "디자인이 적용된 10개 페이지 전체를 대상으로 배너와 애니메이션의 동작, 시각적 일관성을 최종 검수하고 다양한 화면 크기에서의 레이아웃을 확인합니다.",
            "dependencies": [
              "3.2",
              "3.3",
              "3.4"
            ],
            "details": "페이지 간 이동 시에도 디자인이 일관되게 유지되는지 확인합니다. 브라우저 개발자 도구를 사용하여 데스크톱과 모바일 뷰포트에서 배너와 콘텐츠 레이아웃이 깨지지 않는지 점검하고 미세 조정을 진행합니다.",
            "status": "pending",
            "testStrategy": "Task 3의 전체 테스트 전략에 따라 10개 페이지를 모두 방문하며 시각적 검수를 수행하고, 발견된 문제를 수정하여 최종 완료 처리합니다."
          }
        ]
      },
      {
        "id": 4,
        "title": "Headless WordPress API 연동 설정 (Configure Headless WordPress API Integration)",
        "description": "웹사이트에서 Headless WordPress의 데이터를 가져오기 위한 기본 연동 설정을 구축합니다.",
        "details": "WordPress GraphQL 또는 REST API 엔드포인트 연결을 설정하고, 환경 변수를 사용하여 API URL을 안전하게 관리합니다. 지정된 카테고리별로 게시물 목록을 조회하는 기본 데이터 fetching 함수를 구현합니다.",
        "testStrategy": "API 클라이언트(예: Postman)나 테스트 스크립트를 사용하여 특정 카테고리 ID로 게시물 데이터를 성공적으로 가져오는지 확인하고, 반환되는 데이터의 구조를 검증합니다.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "API 방식 결정 및 WordPress 플러그인 설치 (Decide on API method and install WordPress plugins)",
            "description": "프로젝트 요구사항에 맞춰 REST API와 GraphQL 중 사용할 API 방식을 결정합니다. GraphQL을 사용하기로 결정한 경우, WordPress에 WPGraphQL 플러그인을 설치하고 활성화합니다.",
            "dependencies": [],
            "details": "REST API는 WordPress에 기본 내장되어 있으며, GraphQL은 추가 플러그인 설치가 필요합니다. 데이터 요청의 유연성과 성능을 고려하여 적합한 방식을 선택합니다.\n<info added on 2025-09-02T11:12:45.545Z>\n\n\n결정 사항: WordPress에 기본 내장된 REST API를 사용합니다. 별도의 GraphQL 플러그인 설치는 필요하지 않습니다.\n</info added on 2025-09-02T11:12:45.545Z>",
            "status": "pending",
            "testStrategy": "WordPress 관리자 페이지에서 플러그인이 성공적으로 활성화되었는지 확인합니다. GraphQL의 경우 GraphiQL IDE, REST의 경우 브라우저에서 기본 엔드포인트(/wp-json/)에 접근하여 기본 응답이 오는지 확인합니다."
          },
          {
            "id": 2,
            "title": "API 엔드포인트 환경 변수 설정 (Configure API endpoint environment variables)",
            "description": "프론트엔드 프로젝트의 .env 파일에 WordPress API URL을 환경 변수로 추가하여 관리합니다. 이를 통해 소스 코드에서 URL을 분리하여 보안과 관리 용이성을 높입니다.",
            "dependencies": [
              "4.1"
            ],
            "details": "NEXT_PUBLIC_WORDPRESS_API_URL과 같은 명확한 변수명을 사용합니다. 개발, 스테이징, 프로덕션 환경별로 다른 엔드포인트를 설정할 수 있도록 .env.local, .env.development 등의 파일을 활용합니다.\n<info added on 2025-08-31T05:55:10.982Z>\nVite 프로젝트(`seongrim`)의 루트에 `.env.local` 파일을 생성하고, 다음과 같이 환경 변수를 설정합니다. Vite의 규칙에 따라 클라이언트 사이드에서 변수에 접근할 수 있도록 `VITE_` 접두사를 사용합니다.\n```\nVITE_API_URL=https://api.seongrim.o-r.kr/wp-json\n```\n",
            "status": "pending",
            "testStrategy": "프로젝트를 실행한 후, 코드 내에서 process.env.NEXT_PUBLIC_WORDPRESS_API_URL 값을 콘솔에 출력하여 올바른 URL이 로드되는지 확인합니다."
          },
          {
            "id": 3,
            "title": "프론트엔드 API 클라이언트 모듈 생성 (Create a frontend API client module)",
            "description": "API 요청을 중앙에서 처리하기 위한 재사용 가능한 API 클라이언트 모듈을 생성합니다. 이 모듈은 환경 변수에서 API URL을 읽어와 요청의 기본 설정을 담당합니다.",
            "dependencies": [
              "4.2"
            ],
            "details": "axios 또는 fetch API를 사용하여 클라이언트를 구현합니다. GraphQL의 경우, Apollo Client나 graphql-request와 같은 라이브러리를 설정하여 쿼리를 쉽게 보낼 수 있도록 구성합니다.\n<info added on 2025-09-02T11:13:12.985Z>\n프로젝트에 이미 `axios`가 의존성으로 설정되어 있으므로, `axios`를 사용하여 구현합니다.\n</info added on 2025-09-02T11:13:12.985Z>",
            "status": "pending",
            "testStrategy": "생성된 클라이언트 모듈을 사용하여 WordPress의 기본 정보(예: 사이트 제목)를 가져오는 간단한 테스트 함수를 실행하고, 200 OK 응답을 받는지 확인합니다."
          },
          {
            "id": 4,
            "title": "카테고리별 게시물 조회 데이터 fetching 함수 구현 (Implement data fetching function for posts by category)",
            "description": "특정 카테고리 ID를 인자로 받아, 해당 카테고리에 속한 게시물 목록을 조회하는 비동기 함수(예: getPostsByCategory)를 API 클라이언트 모듈을 사용하여 구현합니다.",
            "dependencies": [
              "4.3"
            ],
            "details": "REST API의 경우 `/wp/v2/posts?categories=<id>` 엔드포인트를, GraphQL의 경우 `posts(where: { categoryId: <id> })`와 같은 쿼리를 사용합니다. 함수는 후속 작업(Task 5)에 필요한 필드(제목, 날짜, 요약 등)를 포함하여 반환해야 합니다.\n<info added on 2025-09-02T11:13:39.550Z>\n초기 구현 시, 함수는 각 게시물에 대해 다음 필드를 우선적으로 가져와야 합니다: `id`, `title`, `content`, `excerpt`, `date`, `author`, `featured_media`. 또한, 향후 다른 필드가 필요할 경우 쉽게 추가할 수 있도록 확장성을 고려하여 설계해야 합니다.\n</info added on 2025-09-02T11:13:39.550Z>",
            "status": "pending",
            "testStrategy": "단위 테스트를 작성하여 특정 카테고리 ID를 함수에 전달했을 때, 예상되는 구조의 게시물 데이터 배열이 반환되는지 검증합니다. 존재하지 않는 카테고리 ID에 대한 예외 처리도 확인합니다."
          },
          {
            "id": 5,
            "title": "API 응답 데이터 타입 정의 및 최종 연동 테스트 (Define API response types and conduct final integration test)",
            "description": "API로부터 반환되는 게시물 데이터의 구조에 맞춰 TypeScript 인터페이스 또는 JSDoc 타입을 정의하여 코드의 안정성을 확보합니다. 구현된 fetching 함수를 실제로 호출하여 전체 연동 과정을 테스트합니다.",
            "dependencies": [
              "4.4"
            ],
            "details": "Postman과 같은 도구로 실제 API 응답을 확인하고, 이를 기반으로 'Post' 타입을 정의합니다. 이 타입은 getPostsByCategory 함수의 반환 타입으로 명시하여 타입 안정성을 높입니다.\n<info added on 2025-09-02T11:14:25.045Z>\n프로젝트가 JavaScript로 진행되므로, TypeScript 인터페이스 대신 JSDoc 주석을 활용하여 API 응답 데이터 타입을 정의합니다. 이를 통해 코드 안정성과 개발자 경험을 향상시킵니다.\n</info added on 2025-09-02T11:14:25.045Z>",
            "status": "pending",
            "testStrategy": "테스트용 페이지 컴포넌트에서 getPostsByCategory 함수를 호출하고, 반환된 데이터가 정의된 타입과 일치하는지, 그리고 화면에 정상적으로 렌더링되는지 확인합니다. 데이터가 없을 경우 빈 배열이 올바르게 처리되는지도 테스트합니다."
          }
        ]
      },
      {
        "id": 5,
        "title": "공용 BoardPage 컴포넌트 개발 및 게시판 페이지 구현",
        "description": "초기 계획을 수정하여, 재사용 가능한 BoardPage 공용 컴포넌트를 먼저 개발하고, 이를 활용해 '주보'와 '교회 소식' 페이지를 효율적으로 구현한다. API 응답 헤더(X-WP-TotalPages)를 이용한 페이지네이션과 URL 쿼리 스트링(?page=...)을 통한 페이지 상태 관리를 포함한다.",
        "details": "",
        "testStrategy": "",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "페이지네이션을 지원하는 데이터 Fetching 함수 개선",
            "description": "4번 태스크에서 만든 axios 클라이언트를 개선하여, API 요청 시 응답 본문(게시물 목록)과 함께 응답 헤더의 X-WP-TotalPages 값('전체 페이지 수')을 함께 반환하도록 수정한다. 페이지 번호를 인자로 받아 해당 페이지의 데이터를 요청하는 기능을 포함한다.",
            "dependencies": [],
            "details": "",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "공용 게시물 UI 컴포넌트 개발 (PostList, Pagination)",
            "description": "데이터를 받아 화면에 표시하는 역할만 담당하는 순수 UI 컴포넌트를 개발한다. 1) 게시물 목록과 아이템을 위한 PostList/PostListItem, 2) 페이지 번호를 표시하고 이동 이벤트를 처리할 Pagination 컴포넌트를 포함한다.",
            "dependencies": [],
            "details": "",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "핵심 로직을 담은 'BoardPage' 공용 컴포넌트 개발",
            "description": "categoryId와 title을 props로 받는 재사용 가능한 BoardPage 컴포넌트를 개발한다. 이 컴포넌트는 다음 핵심 로직을 모두 담당한다: 1) URL 쿼리 스트링에서 page 값을 읽어 API 호출, 2) use-effect와 use-state를 사용한 데이터 상태 관리(게시물, 전체 페이지 수, 로딩, 에러), 3) 로딩/에러 상태에 따른 UI 분기 처리, 4) 데이터와 이벤트 핸들러를 UI 컴포넌트(PostList, Pagination)에 전달.",
            "dependencies": [
              "5.1",
              "5.2"
            ],
            "details": "",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "'주보' 및 '교회 소식' 페이지 최종 조립",
            "description": "react-router-dom을 이용해 /bulletin과 /church-news 경로에 페이지를 생성한다. 각 페이지에서는 BoardPage 공용 컴포넌트를 가져와, 각각에 맞는 categoryId와 title props를 전달하여 최종 페이지를 완성한다. (예: <BoardPage categoryId={1} title=\"주보\" />)",
            "dependencies": [
              "5.3"
            ],
            "details": "",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "반응형 디자인 적용 및 최종 테스트",
            "description": "개발된 모든 공용 컴포넌트(PostList, Pagination 등)에 반응형 스타일을 적용한다. 최종 조립된 '주보'와 '교회 소식' 두 페이지가 데스크톱, 태블릿, 모바일 등 다양한 화면 크기에서 정상적으로 표시되는지 확인하고 테스트한다.",
            "dependencies": [
              "5.4"
            ],
            "details": "",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "'앨범' 페이지 갤러리 레이아웃 구현 (Implement 'Album' Page with Gallery Layout)",
        "description": "WordPress '앨범' 게시물의 본문에 포함된 모든 이미지를 가져와, 사진 중심의 갤러리 페이지를 개발한다. 메이슨리(Masonry) 레이아웃, 무한 스크롤, 스켈레톤 로더, 라이트박스 기능을 포함하여 사용자 경험을 극대화한다.",
        "details": "",
        "testStrategy": "",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "'앨범' 게시물 이미지 파싱 및 API 함수 고도화",
            "description": "'앨범' 카테고리 게시물을 페이지별로 요청하고, 각 게시물 본문(HTML)에서 모든 이미지(`<img>`) 태그를 추출하는 데이터 페칭(fetching) 함수를 구현한다. 무한 스크롤을 위해 페이지 번호를 인자로 받고, 전체 페이지 수를 반환하는 기능을 포함한다.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "스켈레톤 UI 및 갤러리 아이템 컴포넌트 개발",
            "description": "데이터 로딩 상태를 표시할 메이슨리 레이아웃 형태의 스켈레톤 UI를 개발한다. 또한, 개별 이미지를 화면에 표시할 `GalleryItem` 컴포넌트를 만든다.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "메이슨리 레이아웃 및 무한 스크롤 기능 구현",
            "description": "`react-masonry-css`를 사용하여 갤러리 레이아웃을 구성한다. 사용자가 페이지 하단에 도달하면 다음 페이지의 이미지를 자동으로 불러와 기존 목록에 추가하는 무한 스크롤 기능을 구현한다.",
            "status": "pending",
            "dependencies": [
              "6.1",
              "6.2"
            ],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "라이트박스 기능 연동",
            "description": "`yet-another-react-lightbox` 라이브러리를 `GalleryItem`과 연동한다. 이미지 클릭 시, 현재까지 로드된 모든 이미지를 탐색할 수 있는 라이트박스가 열리도록 구현한다.",
            "status": "pending",
            "dependencies": [
              "6.3"
            ],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "반응형 디자인 최종 적용 및 통합 테스트",
            "description": "메이슨리 레이아웃, 무한 스크롤, 라이트박스 등 구현된 모든 기능이 데스크톱, 태블릿, 모바일 환경에서 올바르게 동작하는지 최종 테스트하고 디자인을 미세 조정한다.",
            "status": "pending",
            "dependencies": [
              "6.4"
            ],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 9,
        "title": "YouTube 연동 페이지 프론트엔드 UI/UX 구현 (Implement YouTube Integration Frontend UI)",
        "description": "주일 설교, 찬양대, 특별 찬양 페이지에서 자체 백엔드 API를 통해 영상 목록을 받아와 카드 형태로 표시합니다.",
        "details": "3개의 각 페이지는 자체 백엔드 API 엔드포인트(Task 8)를 호출하여 영상 데이터를 가져옵니다. 썸네일, 제목, 재생 시간 등의 정보를 포함하는 카드 UI 컴포넌트를 개발하고, 이를 사용하여 비디오 목록을 렌더링합니다.",
        "testStrategy": "각 페이지가 올바른 재생목록 데이터를 표시하는지 확인합니다. 카드 UI가 디자인 시안과 일치하는지, 반응형 디자인이 잘 적용되었는지 다양한 디바이스에서 검수합니다. 데이터 로딩 중/에러 발생 시의 UI 상태도 확인합니다.",
        "priority": "high",
        "dependencies": [
          "12"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "재사용 가능한 '영상 카드' UI 컴포넌트 개발",
            "description": "YouTube 영상의 썸네일, 제목, 재생 시간 등 주요 정보를 표시하는 재사용 가능한 카드 형태의 UI 컴포넌트를 개발합니다. 이 컴포넌트는 모든 영상 목록 페이지에서 공통으로 사용됩니다.",
            "dependencies": [],
            "details": "props를 통해 영상 데이터(thumbnailUrl, title, duration)를 받아 동적으로 렌더링하도록 구현합니다. 디자인 시안에 맞춰 HTML 구조와 CSS 스타일링을 적용하고, 클릭 시 YouTube 영상 페이지로 이동하는 링크를 포함합니다.",
            "status": "pending",
            "testStrategy": "Storybook과 같은 UI 개발 도구를 사용하여 다양한 제목 길이와 썸네일 이미지에 대해 컴포넌트가 깨짐 없이 렌더링되는지 확인합니다."
          },
          {
            "id": 2,
            "title": "백엔드 API 연동을 위한 데이터 페칭 로직 구현",
            "description": "Task 8에서 개발된 백엔드 API 엔드포인트를 호출하여 특정 재생목록의 영상 데이터를 가져오는 로직을 구현합니다. 데이터 로딩, 성공, 실패 상태를 관리하는 기능을 포함합니다.",
            "dependencies": [],
            "details": "재사용성을 높이기 위해 React Query나 SWR과 같은 데이터 페칭 라이브러리를 사용하거나, `useFetchVideos`와 같은 커스텀 훅(Hook) 형태로 구현합니다. 이 훅은 playlistId를 인자로 받아 { data, isLoading, error } 상태 객체를 반환해야 합니다.",
            "status": "pending",
            "testStrategy": "모의 API 서버(Mock Service Worker 등)를 사용하여 성공, 로딩 중, 에러 발생 시나리오별로 훅이 올바른 상태를 반환하는지 단위 테스트를 진행합니다."
          },
          {
            "id": 3,
            "title": "'주일 설교' 페이지 구현 및 영상 목록 렌더링",
            "description": "'주일 설교' 페이지의 전체 레이아웃을 구성하고, 개발된 데이터 페칭 로직과 영상 카드 컴포넌트를 조합하여 실제 영상 목록을 화면에 렌더링합니다.",
            "dependencies": [
              "9.1",
              "9.2"
            ],
            "details": "데이터 페칭 로직을 호출하여 '주일 설교' 재생목록 데이터를 가져옵니다. 로딩 중일 때는 스켈레톤 UI를, 에러 발생 시에는 사용자에게 안내 메시지를 표시합니다. 데이터 로딩이 완료되면 영상 카드 컴포넌트를 그리드 형태로 나열하여 목록을 표시합니다.",
            "status": "pending",
            "testStrategy": "브라우저에서 페이지를 직접 확인하여 영상 목록이 올바르게 표시되는지, 로딩 및 에러 상태 UI가 정상적으로 작동하는지 검증합니다."
          },
          {
            "id": 4,
            "title": "'찬양대' 및 '특별 찬양' 페이지 구현",
            "description": "'주일 설교' 페이지와 동일한 구조를 재사용하여 '찬양대'와 '특별 찬양' 페이지를 구현합니다. 각 페이지에 맞는 재생목록 데이터를 API로부터 가져와 표시합니다.",
            "dependencies": [
              "9.3"
            ],
            "details": "기존에 구현된 페이지 구조와 컴포넌트를 재활용하되, 각 페이지에 해당하는 고유한 playlistId를 데이터 페칭 로직에 전달하여 올바른 영상 목록을 불러오도록 설정합니다.",
            "status": "pending",
            "testStrategy": "각 페이지를 방문하여 해당 재생목록(찬양대, 특별 찬양)의 영상들이 정확하게 렌더링되는지 확인합니다."
          },
          {
            "id": 5,
            "title": "반응형 디자인 적용 및 최종 UI 검수",
            "description": "구현된 3개의 영상 목록 페이지 전체에 반응형 디자인을 적용하여 데스크톱, 태블릿, 모바일 등 다양한 디바이스에서 최적화된 UI/UX를 제공하도록 합니다.",
            "dependencies": [
              "9.4"
            ],
            "details": "미디어 쿼리를 사용하여 화면 너비에 따라 영상 카드 그리드의 컬럼 수를 동적으로 변경합니다. (예: 데스크톱 4열, 태블릿 2열, 모바일 1열) 폰트 크기, 여백 등을 조절하여 가독성을 확보합니다.",
            "status": "pending",
            "testStrategy": "브라우저 개발자 도구의 디바이스 에뮬레이션 기능을 사용하여 주요 해상도별로 레이아웃이 깨지지 않는지 확인하고, 실제 모바일 기기에서도 테스트를 진행합니다."
          },
          {
            "id": 6,
            "title": "YouTubeVideoList 컴포넌트 개발",
            "description": "src/components/YouTubeVideoList.jsx 컴포넌트를 생성하여 YouTube 영상 목록을 표시하도록 구현합니다. playlistId를 prop으로 받아 백엔드 API를 호출하고, position 순서대로 영상을 정렬하여 썸네일, 제목, 게시일 등을 표시합니다.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 9
          },
          {
            "id": 7,
            "title": "VideoModal 컴포넌트 개발 및 스타일링",
            "description": "src/components/VideoModal.jsx 컴포넌트와 src/components/VideoModal.css 파일을 생성하여 영상 클릭 시 모달 창에서 YouTube 영상을 재생하는 기능을 구현합니다.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 9
          },
          {
            "id": 8,
            "title": "주일설교, 찬양대, 특별찬양 페이지에 컴포넌트 통합",
            "description": "SundaySermonPage.jsx, ChoirPage.jsx, SpecialPraisePage.jsx 세 페이지를 수정하여 기존의 가상 데이터를 제거하고, YouTubeVideoList와 VideoModal 컴포넌트를 통합합니다. 각 페이지에는 해당 플레이리스트 ID를 설정할 수 있는 플레이스홀더를 추가합니다.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 9
          }
        ]
      },
      {
        "id": 10,
        "title": "최종 통합 테스트 및 배포 준비 (Final Integration Testing & Deployment Prep)",
        "description": "구현된 모든 기능(디자인 개선, WordPress 연동, YouTube 연동)이 서로 문제없이 동작하는지 전체적으로 테스트하고 배포를 준비합니다.",
        "details": "스테이징(Staging) 환경에서 모든 페이지와 기능을 점검합니다. 특히 페이지 간 이동, 데이터 로딩 속도, 애니메이션 효과 등 실제 사용자 시나리오를 기반으로 테스트를 진행하고 발견된 버그를 수정합니다.",
        "testStrategy": "QA 체크리스트를 작성하여 PRD의 모든 요구사항이 충족되었는지 확인합니다. 여러 브라우저(Chrome, Safari, Firefox)와 디바이스(데스크톱, 모바일)에서 크로스 브라우징 및 반응형 테스트를 수행합니다.",
        "priority": "medium",
        "dependencies": [
          3,
          5,
          6,
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "통합 테스트 시나리오 및 QA 체크리스트 작성",
            "description": "PRD 요구사항과 실제 사용자 시나리오를 기반으로, WordPress와 YouTube 연동을 포함한 모든 기능의 상호작용을 검증할 수 있는 상세한 테스트 케이스와 QA 체크리스트를 작성합니다.",
            "dependencies": [],
            "details": "체크리스트에는 페이지 간 이동, 데이터 로딩, 애니메이션 효과, 에러 처리 등 기능적 요구사항과 비기능적 요구사항(성능, UI 일관성)을 모두 포함해야 합니다.",
            "status": "pending",
            "testStrategy": "작성된 체크리스트를 팀원과 함께 리뷰하여 테스트 커버리지를 검증하고 누락된 항목이 없는지 확인합니다."
          },
          {
            "id": 2,
            "title": "주요 기능 통합 테스트 실행 및 버그 리포팅",
            "description": "스테이징 환경에서 QA 체크리스트에 따라 WordPress 연동 기능(주보, 소식, 앨범)과 YouTube 연동 기능(설교, 찬양)이 서로 충돌 없이 정상적으로 동작하는지 테스트하고 발견된 버그를 기록합니다.",
            "dependencies": [
              "10.1"
            ],
            "details": "WordPress 관리자 페이지에서 콘텐츠를 변경했을 때 웹사이트에 즉시 또는 지정된 시간 내에 반영되는지, YouTube API 캐시 데이터가 프론트엔드에 올바르게 표시되는지 등을 중점적으로 확인합니다.",
            "status": "pending",
            "testStrategy": "발견된 모든 버그는 재현 경로, 기대 결과, 실제 결과, 스크린샷을 포함하여 이슈 트래킹 시스템에 상세히 기록합니다."
          },
          {
            "id": 3,
            "title": "크로스 브라우징 및 반응형 UI/UX 검증",
            "description": "주요 웹 브라우저(Chrome, Safari, Firefox)와 다양한 디바이스(데스크톱, 태블릿, 모바일) 환경에서 모든 페이지의 레이아웃, 폰트, 인터랙션이 의도대로 일관되게 표시되고 동작하는지 검증합니다.",
            "dependencies": [
              "10.1"
            ],
            "details": "브라우저 개발자 도구의 에뮬레이터와 실제 기기를 병행하여 테스트합니다. 특히 동적 콘텐츠가 로드되었을 때 레이아웃이 깨지지 않는지, 터치 이벤트가 정상적으로 작동하는지 등을 확인합니다.",
            "status": "pending",
            "testStrategy": "디자인 시안과 실제 구현물을 비교하며 픽셀 단위의 차이까지 점검하고, UI 불일치 항목을 리포트합니다."
          },
          {
            "id": 4,
            "title": "성능 측정 및 사용자 경험(UX) 최종 점검",
            "description": "웹사이트의 전반적인 로딩 속도, 데이터 처리 효율성, 애니메이션 부드러움 등 성능을 측정하고 사용자 경험을 저해하는 요소를 찾아 개선합니다.",
            "dependencies": [
              "10.1"
            ],
            "details": "Google Lighthouse, PageSpeed Insights 등의 도구를 사용하여 성능 점수를 측정합니다. 이미지 최적화, 코드 스플리팅, 불필요한 API 호출 여부 등을 분석하고 개선 방안을 도출합니다.",
            "status": "pending",
            "testStrategy": "주요 페이지(메인, 게시물 목록, 상세 페이지)의 LCP(Largest Contentful Paint), TTI(Time to Interactive) 지표를 측정하고, 목표 기준치 미달 시 원인을 분석하여 리포트합니다."
          },
          {
            "id": 5,
            "title": "최종 버그 수정 및 프로덕션 빌드 준비",
            "description": "통합 테스트 과정(기능, UI, 성능)에서 발견된 모든 버그를 수정하고, 수정 사항에 대한 회귀 테스트를 진행한 후 배포를 위한 최종 프로덕션 빌드를 생성합니다.",
            "dependencies": [
              "10.2",
              "10.3",
              "10.4"
            ],
            "details": "모든 버그 수정이 완료되면 코드 프리즈(Code Freeze)를 진행합니다. 프로덕션 환경 변수(.env.production)를 최종 확인하고, 코드 압축 및 최적화 옵션을 활성화하여 빌드합니다.",
            "status": "pending",
            "testStrategy": "생성된 프로덕션 빌드 결과물을 스테이징 환경에 마지막으로 배포하여, 빌드 과정 자체의 오류나 환경 변수 설정 오류가 없는지 최종 검증합니다."
          }
        ]
      },
      {
        "id": 11,
        "title": "백엔드 YouTube 데이터 캐싱 시스템 구축 (MariaDB 기반)",
        "description": "YouTube API 할당량의 효율적 관리를 위해, '/var/www/html/project/mev_home-backend' Express 서버에 데이터 캐싱 시스템을 구축합니다. 이 시스템은 매주 일요일 오후 3시에 YouTube API를 호출하여 영상 데이터를 MariaDB 데이터베이스에 저장하는 역할을 합니다.",
        "details": "저장될 데이터는 영상의 'title'과 'url' 두 가지입니다. 스케줄링 작업(Cron Job)을 설정하여 동기화 프로세스를 자동화해야 합니다. 또한, API 키와 같은 민감 정보는 .env 파일을 통해 안전하게 관리되어야 합니다.",
        "testStrategy": "1. 스케줄링 작업이 매주 일요일 오후 3시에 정확히 실행되는지 서버 로그를 통해 확인합니다. 2. 동기화 작업 후, MariaDB의 관련 테이블에 영상 제목과 URL 데이터가 올바르게 저장되었는지 직접 확인합니다. 3. 의도적으로 잘못된 API 키를 사용하여 API 호출 실패 시, 오류 처리 및 로깅이 정상적으로 동작하는지 검증합니다.",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "캐시된 YouTube 데이터 제공 API 엔드포인트 개발",
        "description": "프론트엔드에서 사용할 수 있도록, '/var/www/html/project/mev_home-backend' Express 서버에 캐시된 YouTube 영상 목록을 제공하는 API 엔드포인트를 개발합니다.",
        "details": "API 규격은 다음과 같습니다: 1. 엔드포인트: GET /api/youtube-videos 2. 요청 파라미터: playlistId (예: /api/youtube-videos?playlistId=...) 3. 성공 응답: MariaDB에서 조회한 영상 목록을 JSON 배열 형태로 반환합니다. 각 객체는 'title'과 'url' 키를 포함해야 합니다. (예: [{ \\\"title\\\": \\\"영상 제목\\\", \\\"url\\\": \\\"...\\\" }])",
        "testStrategy": "1. API 클라이언트(Postman 등)를 사용하여 유효한 playlistId로 API를 호출했을 때, 200 OK 상태 코드와 함께 올바른 JSON 형식의 데이터가 반환되는지 확인합니다. 2. playlistId를 누락하거나 유효하지 않은 ID로 요청했을 때, 400 Bad Request와 같은 적절한 에러 코드가 반환되는지 확인합니다. 3. DB에 존재하지 않는 playlistId로 요청 시, 404 Not Found 에러가 반환되는지 확인합니다.",
        "status": "pending",
        "dependencies": [
          11
        ],
        "priority": "high",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-31T02:52:25.742Z",
      "updated": "2025-09-03T10:47:11.849Z",
      "description": "Tasks for phase-2 context"
    }
  }
}